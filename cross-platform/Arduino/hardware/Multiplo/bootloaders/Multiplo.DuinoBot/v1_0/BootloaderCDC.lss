
BootloaderCDC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000092  00800100  00007e4a  00000ede  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e4a  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000e  00800192  00800192  00000f70  2**0
                  ALLOC
  3 .debug_aranges 00000260  00000000  00000000  00000f70  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000006e7  00000000  00000000  000011d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002d6b  00000000  00000000  000018b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000c0f  00000000  00000000  00004622  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002b13  00000000  00000000  00005231  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003a0  00000000  00000000  00007d44  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000014b5  00000000  00000000  000080e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002504  00000000  00000000  00009599  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000003c0  00000000  00000000  0000ba9d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
#endif

uint8_t Endpoint_BytesToEPSizeMaskDynamic(const uint16_t Size)
{
	return Endpoint_BytesToEPSizeMask(Size);
}
    7000:	55 c0       	rjmp	.+170    	; 0x70ac <__ctors_end>
    7002:	00 00       	nop
    7004:	6e c0       	rjmp	.+220    	; 0x70e2 <__bad_interrupt>
    7006:	00 00       	nop
    7008:	6c c0       	rjmp	.+216    	; 0x70e2 <__bad_interrupt>
    700a:	00 00       	nop
    700c:	6a c0       	rjmp	.+212    	; 0x70e2 <__bad_interrupt>
    700e:	00 00       	nop
    7010:	68 c0       	rjmp	.+208    	; 0x70e2 <__bad_interrupt>
    7012:	00 00       	nop
    7014:	66 c0       	rjmp	.+204    	; 0x70e2 <__bad_interrupt>
    7016:	00 00       	nop
    7018:	64 c0       	rjmp	.+200    	; 0x70e2 <__bad_interrupt>
    701a:	00 00       	nop
    701c:	62 c0       	rjmp	.+196    	; 0x70e2 <__bad_interrupt>
    701e:	00 00       	nop
    7020:	60 c0       	rjmp	.+192    	; 0x70e2 <__bad_interrupt>
    7022:	00 00       	nop
    7024:	5e c0       	rjmp	.+188    	; 0x70e2 <__bad_interrupt>
    7026:	00 00       	nop
    7028:	42 c6       	rjmp	.+3204   	; 0x7cae <__vector_10>
    702a:	00 00       	nop
    702c:	5a c0       	rjmp	.+180    	; 0x70e2 <__bad_interrupt>
    702e:	00 00       	nop
    7030:	58 c0       	rjmp	.+176    	; 0x70e2 <__bad_interrupt>
    7032:	00 00       	nop
    7034:	56 c0       	rjmp	.+172    	; 0x70e2 <__bad_interrupt>
    7036:	00 00       	nop
    7038:	54 c0       	rjmp	.+168    	; 0x70e2 <__bad_interrupt>
    703a:	00 00       	nop
    703c:	52 c0       	rjmp	.+164    	; 0x70e2 <__bad_interrupt>
    703e:	00 00       	nop
    7040:	50 c0       	rjmp	.+160    	; 0x70e2 <__bad_interrupt>
    7042:	00 00       	nop
    7044:	4e c0       	rjmp	.+156    	; 0x70e2 <__bad_interrupt>
    7046:	00 00       	nop
    7048:	4c c0       	rjmp	.+152    	; 0x70e2 <__bad_interrupt>
    704a:	00 00       	nop
    704c:	4a c0       	rjmp	.+148    	; 0x70e2 <__bad_interrupt>
    704e:	00 00       	nop
    7050:	48 c0       	rjmp	.+144    	; 0x70e2 <__bad_interrupt>
    7052:	00 00       	nop
    7054:	46 c0       	rjmp	.+140    	; 0x70e2 <__bad_interrupt>
    7056:	00 00       	nop
    7058:	44 c0       	rjmp	.+136    	; 0x70e2 <__bad_interrupt>
    705a:	00 00       	nop
    705c:	42 c0       	rjmp	.+132    	; 0x70e2 <__bad_interrupt>
    705e:	00 00       	nop
    7060:	40 c0       	rjmp	.+128    	; 0x70e2 <__bad_interrupt>
    7062:	00 00       	nop
    7064:	3e c0       	rjmp	.+124    	; 0x70e2 <__bad_interrupt>
    7066:	00 00       	nop
    7068:	3c c0       	rjmp	.+120    	; 0x70e2 <__bad_interrupt>
    706a:	00 00       	nop
    706c:	3a c0       	rjmp	.+116    	; 0x70e2 <__bad_interrupt>
    706e:	00 00       	nop
    7070:	38 c0       	rjmp	.+112    	; 0x70e2 <__bad_interrupt>
    7072:	00 00       	nop
    7074:	36 c0       	rjmp	.+108    	; 0x70e2 <__bad_interrupt>
    7076:	00 00       	nop
    7078:	34 c0       	rjmp	.+104    	; 0x70e2 <__bad_interrupt>
    707a:	00 00       	nop
    707c:	32 c0       	rjmp	.+100    	; 0x70e2 <__bad_interrupt>
    707e:	00 00       	nop
    7080:	30 c0       	rjmp	.+96     	; 0x70e2 <__bad_interrupt>
    7082:	00 00       	nop
    7084:	2e c0       	rjmp	.+92     	; 0x70e2 <__bad_interrupt>
    7086:	00 00       	nop
    7088:	2c c0       	rjmp	.+88     	; 0x70e2 <__bad_interrupt>
    708a:	00 00       	nop
    708c:	2a c0       	rjmp	.+84     	; 0x70e2 <__bad_interrupt>
    708e:	00 00       	nop
    7090:	28 c0       	rjmp	.+80     	; 0x70e2 <__bad_interrupt>
    7092:	00 00       	nop
    7094:	26 c0       	rjmp	.+76     	; 0x70e2 <__bad_interrupt>
    7096:	00 00       	nop
    7098:	24 c0       	rjmp	.+72     	; 0x70e2 <__bad_interrupt>
    709a:	00 00       	nop
    709c:	22 c0       	rjmp	.+68     	; 0x70e2 <__bad_interrupt>
    709e:	00 00       	nop
    70a0:	20 c0       	rjmp	.+64     	; 0x70e2 <__bad_interrupt>
    70a2:	00 00       	nop
    70a4:	1e c0       	rjmp	.+60     	; 0x70e2 <__bad_interrupt>
    70a6:	00 00       	nop
    70a8:	1c c0       	rjmp	.+56     	; 0x70e2 <__bad_interrupt>
    70aa:	00 00       	nop

000070ac <__ctors_end>:
    70ac:	11 24       	eor	r1, r1
    70ae:	1f be       	out	0x3f, r1	; 63
    70b0:	cf ef       	ldi	r28, 0xFF	; 255
    70b2:	da e0       	ldi	r29, 0x0A	; 10
    70b4:	de bf       	out	0x3e, r29	; 62
    70b6:	cd bf       	out	0x3d, r28	; 61

000070b8 <__do_copy_data>:
    70b8:	11 e0       	ldi	r17, 0x01	; 1
    70ba:	a0 e0       	ldi	r26, 0x00	; 0
    70bc:	b1 e0       	ldi	r27, 0x01	; 1
    70be:	ea e4       	ldi	r30, 0x4A	; 74
    70c0:	fe e7       	ldi	r31, 0x7E	; 126
    70c2:	02 c0       	rjmp	.+4      	; 0x70c8 <.do_copy_data_start>

000070c4 <.do_copy_data_loop>:
    70c4:	05 90       	lpm	r0, Z+
    70c6:	0d 92       	st	X+, r0

000070c8 <.do_copy_data_start>:
    70c8:	a2 39       	cpi	r26, 0x92	; 146
    70ca:	b1 07       	cpc	r27, r17
    70cc:	d9 f7       	brne	.-10     	; 0x70c4 <.do_copy_data_loop>

000070ce <__do_clear_bss>:
    70ce:	11 e0       	ldi	r17, 0x01	; 1
    70d0:	a2 e9       	ldi	r26, 0x92	; 146
    70d2:	b1 e0       	ldi	r27, 0x01	; 1
    70d4:	01 c0       	rjmp	.+2      	; 0x70d8 <.do_clear_bss_start>

000070d6 <.do_clear_bss_loop>:
    70d6:	1d 92       	st	X+, r1

000070d8 <.do_clear_bss_start>:
    70d8:	a0 3a       	cpi	r26, 0xA0	; 160
    70da:	b1 07       	cpc	r27, r17
    70dc:	e1 f7       	brne	.-8      	; 0x70d6 <.do_clear_bss_loop>
    70de:	53 d3       	rcall	.+1702   	; 0x7786 <main>
    70e0:	b2 c6       	rjmp	.+3428   	; 0x7e46 <_exit>

000070e2 <__bad_interrupt>:
    70e2:	8e cf       	rjmp	.-228    	; 0x7000 <__vectors>

000070e4 <Bootloader_StartUserApp>:
    //(void)(*AppPtr)(void) = 0x0000;
   
	AppPtr_t AppStartPtr = (AppPtr_t)0x0000;
	
    /* Set GPIOR registers to a magic key that will be read by the user application */
    GPIOR0 = 0xDC;
    70e4:	8c ed       	ldi	r24, 0xDC	; 220
    70e6:	8e bb       	out	0x1e, r24	; 30
    GPIOR1 = 0xA5;
    70e8:	85 ea       	ldi	r24, 0xA5	; 165
    70ea:	8a bd       	out	0x2a, r24	; 42
 
    AppStartPtr();
    70ec:	e0 e0       	ldi	r30, 0x00	; 0
    70ee:	f0 e0       	ldi	r31, 0x00	; 0
    70f0:	09 95       	icall

000070f2 <FetchNextCommandByte>:
 *  \return Next received byte from the host in the CDC data OUT endpoint
 */
static uint8_t FetchNextCommandByte(void)
{
	/* Select the OUT endpoint so that the next data byte can be read */
	Endpoint_SelectEndpoint(CDC_RX_EPNUM);
    70f2:	82 e0       	ldi	r24, 0x02	; 2
    70f4:	80 93 e9 00 	sts	0x00E9, r24
    70f8:	11 c0       	rjmp	.+34     	; 0x711c <FetchNextCommandByte+0x2a>
	
	/* If OUT endpoint empty, clear it and wait for the next packet from the host */
	while (!(Endpoint_IsReadWriteAllowed()))
	{
		Endpoint_ClearOUT();
    70fa:	80 91 e8 00 	lds	r24, 0x00E8
    70fe:	98 2f       	mov	r25, r24
    7100:	9b 7f       	andi	r25, 0xFB	; 251
    7102:	90 93 e8 00 	sts	0x00E8, r25
    7106:	8f 77       	andi	r24, 0x7F	; 127
    7108:	80 93 e8 00 	sts	0x00E8, r24
    710c:	03 c0       	rjmp	.+6      	; 0x7114 <FetchNextCommandByte+0x22>

		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    710e:	8e b3       	in	r24, 0x1e	; 30
    7110:	88 23       	and	r24, r24
    7112:	51 f0       	breq	.+20     	; 0x7128 <FetchNextCommandByte+0x36>
	/* If OUT endpoint empty, clear it and wait for the next packet from the host */
	while (!(Endpoint_IsReadWriteAllowed()))
	{
		Endpoint_ClearOUT();

		while (!(Endpoint_IsOUTReceived()))
    7114:	80 91 e8 00 	lds	r24, 0x00E8
    7118:	82 ff       	sbrs	r24, 2
    711a:	f9 cf       	rjmp	.-14     	; 0x710e <FetchNextCommandByte+0x1c>
{
	/* Select the OUT endpoint so that the next data byte can be read */
	Endpoint_SelectEndpoint(CDC_RX_EPNUM);
	
	/* If OUT endpoint empty, clear it and wait for the next packet from the host */
	while (!(Endpoint_IsReadWriteAllowed()))
    711c:	80 91 e8 00 	lds	r24, 0x00E8
    7120:	85 ff       	sbrs	r24, 5
    7122:	eb cf       	rjmp	.-42     	; 0x70fa <FetchNextCommandByte+0x8>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    7124:	80 91 f1 00 	lds	r24, 0x00F1
		}
	}
	
	/* Fetch the next byte from the OUT endpoint */
	return Endpoint_Read_Byte();
}
    7128:	08 95       	ret

0000712a <WriteNextResponseByte>:
 *  bank when full ready for the next byte in the packet to the host.
 *
 *  \param[in] Response  Next response byte to send to the host
 */
static void WriteNextResponseByte(const uint8_t Response)
{
    712a:	28 2f       	mov	r18, r24
	/* Select the IN endpoint so that the next data byte can be written */
	Endpoint_SelectEndpoint(CDC_TX_EPNUM);
    712c:	81 e0       	ldi	r24, 0x01	; 1
    712e:	80 93 e9 00 	sts	0x00E9, r24
	
	/* If IN endpoint full, clear it and wait until ready for the next packet to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    7132:	80 91 e8 00 	lds	r24, 0x00E8
    7136:	85 fd       	sbrc	r24, 5
    7138:	11 c0       	rjmp	.+34     	; 0x715c <WriteNextResponseByte+0x32>
	{
		Endpoint_ClearIN();
    713a:	80 91 e8 00 	lds	r24, 0x00E8
    713e:	98 2f       	mov	r25, r24
    7140:	9e 7f       	andi	r25, 0xFE	; 254
    7142:	90 93 e8 00 	sts	0x00E8, r25
    7146:	8f 77       	andi	r24, 0x7F	; 127
    7148:	80 93 e8 00 	sts	0x00E8, r24
    714c:	03 c0       	rjmp	.+6      	; 0x7154 <WriteNextResponseByte+0x2a>
		
		while (!(Endpoint_IsINReady()))
		{				
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    714e:	8e b3       	in	r24, 0x1e	; 30
    7150:	88 23       	and	r24, r24
    7152:	31 f0       	breq	.+12     	; 0x7160 <WriteNextResponseByte+0x36>
	/* If IN endpoint full, clear it and wait until ready for the next packet to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
	{
		Endpoint_ClearIN();
		
		while (!(Endpoint_IsINReady()))
    7154:	80 91 e8 00 	lds	r24, 0x00E8
    7158:	80 ff       	sbrs	r24, 0
    715a:	f9 cf       	rjmp	.-14     	; 0x714e <WriteNextResponseByte+0x24>
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    715c:	20 93 f1 00 	sts	0x00F1, r18
    7160:	08 95       	ret

00007162 <CDC_Task>:

/** Task to read in AVR910 commands from the CDC data OUT endpoint, process them, perform the required actions
 *  and send the appropriate response back to the host.
 */
void CDC_Task(void)
{
    7162:	4f 92       	push	r4
    7164:	5f 92       	push	r5
    7166:	6f 92       	push	r6
    7168:	7f 92       	push	r7
    716a:	8f 92       	push	r8
    716c:	9f 92       	push	r9
    716e:	af 92       	push	r10
    7170:	bf 92       	push	r11
    7172:	cf 92       	push	r12
    7174:	df 92       	push	r13
    7176:	ef 92       	push	r14
    7178:	ff 92       	push	r15
    717a:	0f 93       	push	r16
    717c:	1f 93       	push	r17
    717e:	cf 93       	push	r28
    7180:	df 93       	push	r29
	/* Select the OUT endpoint */
	Endpoint_SelectEndpoint(CDC_RX_EPNUM);
    7182:	82 e0       	ldi	r24, 0x02	; 2
    7184:	80 93 e9 00 	sts	0x00E9, r24
	
	/* Check if endpoint has a command in it sent from the host */
	if (Endpoint_IsOUTReceived())
    7188:	80 91 e8 00 	lds	r24, 0x00E8
    718c:	82 ff       	sbrs	r24, 2
    718e:	69 c2       	rjmp	.+1234   	; 0x7662 <CDC_Task+0x500>
	{
		/* Read in the bootloader command (first byte sent from host) */
		uint8_t Command = FetchNextCommandByte();
    7190:	b0 df       	rcall	.-160    	; 0x70f2 <FetchNextCommandByte>
    7192:	18 2f       	mov	r17, r24

		if ((Command == 'L') || (Command == 'P') || (Command == 'T') || (Command == 'E'))
    7194:	8c 34       	cpi	r24, 0x4C	; 76
    7196:	09 f4       	brne	.+2      	; 0x719a <CDC_Task+0x38>
    7198:	00 c2       	rjmp	.+1024   	; 0x759a <CDC_Task+0x438>
    719a:	80 35       	cpi	r24, 0x50	; 80
    719c:	09 f4       	brne	.+2      	; 0x71a0 <CDC_Task+0x3e>
    719e:	fd c1       	rjmp	.+1018   	; 0x759a <CDC_Task+0x438>
    71a0:	84 35       	cpi	r24, 0x54	; 84
    71a2:	29 f0       	breq	.+10     	; 0x71ae <CDC_Task+0x4c>
    71a4:	85 34       	cpi	r24, 0x45	; 69
    71a6:	29 f4       	brne	.+10     	; 0x71b2 <CDC_Task+0x50>
		{
			if (Command == 'E')
			  RunBootloader = false;
    71a8:	10 92 0f 01 	sts	0x010F, r1
    71ac:	f6 c1       	rjmp	.+1004   	; 0x759a <CDC_Task+0x438>
			if (Command == 'T')
			  FetchNextCommandByte();
    71ae:	a1 df       	rcall	.-190    	; 0x70f2 <FetchNextCommandByte>
    71b0:	f4 c1       	rjmp	.+1000   	; 0x759a <CDC_Task+0x438>

			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');			
		}
		else if (Command == 't')
    71b2:	84 37       	cpi	r24, 0x74	; 116
    71b4:	21 f4       	brne	.+8      	; 0x71be <CDC_Task+0x5c>
		{
			/* Return ATMEGA128 part code - this is only to allow AVRProg to use the bootloader */
			WriteNextResponseByte(0x44);
    71b6:	84 e4       	ldi	r24, 0x44	; 68
    71b8:	b8 df       	rcall	.-144    	; 0x712a <WriteNextResponseByte>

			WriteNextResponseByte(0x00);
    71ba:	80 e0       	ldi	r24, 0x00	; 0
    71bc:	1c c2       	rjmp	.+1080   	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'a')
    71be:	81 36       	cpi	r24, 0x61	; 97
    71c0:	11 f4       	brne	.+4      	; 0x71c6 <CDC_Task+0x64>
		{
			/* Indicate auto-address increment is supported */
			WriteNextResponseByte('Y');
    71c2:	89 e5       	ldi	r24, 0x59	; 89
    71c4:	18 c2       	rjmp	.+1072   	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'A')
    71c6:	81 34       	cpi	r24, 0x41	; 65
    71c8:	e9 f4       	brne	.+58     	; 0x7204 <CDC_Task+0xa2>
		{
			/* Set the current address to that given by the host */
			CurrAddress   = (FetchNextCommandByte() << 9);
    71ca:	93 df       	rcall	.-218    	; 0x70f2 <FetchNextCommandByte>
    71cc:	f8 2e       	mov	r15, r24
    71ce:	ff 0c       	add	r15, r15
    71d0:	ee 24       	eor	r14, r14
    71d2:	00 27       	eor	r16, r16
    71d4:	f7 fc       	sbrc	r15, 7
    71d6:	00 95       	com	r16
    71d8:	10 2f       	mov	r17, r16
    71da:	e0 92 92 01 	sts	0x0192, r14
    71de:	f0 92 93 01 	sts	0x0193, r15
    71e2:	00 93 94 01 	sts	0x0194, r16
    71e6:	10 93 95 01 	sts	0x0195, r17
			CurrAddress  |= (FetchNextCommandByte() << 1);
    71ea:	83 df       	rcall	.-250    	; 0x70f2 <FetchNextCommandByte>
    71ec:	90 e0       	ldi	r25, 0x00	; 0
    71ee:	88 0f       	add	r24, r24
    71f0:	99 1f       	adc	r25, r25
    71f2:	aa 27       	eor	r26, r26
    71f4:	97 fd       	sbrc	r25, 7
    71f6:	a0 95       	com	r26
    71f8:	ba 2f       	mov	r27, r26
    71fa:	8e 29       	or	r24, r14
    71fc:	9f 29       	or	r25, r15
    71fe:	a0 2b       	or	r26, r16
    7200:	b1 2b       	or	r27, r17
    7202:	c3 c1       	rjmp	.+902    	; 0x758a <CDC_Task+0x428>

			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');
		}
		else if (Command == 'p')
    7204:	80 37       	cpi	r24, 0x70	; 112
    7206:	11 f4       	brne	.+4      	; 0x720c <CDC_Task+0xaa>
		{
			/* Indicate serial programmer back to the host */
			WriteNextResponseByte('S');		 
    7208:	83 e5       	ldi	r24, 0x53	; 83
    720a:	f5 c1       	rjmp	.+1002   	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'S')
    720c:	83 35       	cpi	r24, 0x53	; 83
    720e:	49 f4       	brne	.+18     	; 0x7222 <CDC_Task+0xc0>
    7210:	c0 e0       	ldi	r28, 0x00	; 0
    7212:	d1 e0       	ldi	r29, 0x01	; 1
		{
			/* Write the 7-byte software identifier to the endpoint */
			for (uint8_t CurrByte = 0; CurrByte < 7; CurrByte++)
			  WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);		
    7214:	89 91       	ld	r24, Y+
    7216:	89 df       	rcall	.-238    	; 0x712a <WriteNextResponseByte>
			WriteNextResponseByte('S');		 
		}
		else if (Command == 'S')
		{
			/* Write the 7-byte software identifier to the endpoint */
			for (uint8_t CurrByte = 0; CurrByte < 7; CurrByte++)
    7218:	21 e0       	ldi	r18, 0x01	; 1
    721a:	c7 30       	cpi	r28, 0x07	; 7
    721c:	d2 07       	cpc	r29, r18
    721e:	d1 f7       	brne	.-12     	; 0x7214 <CDC_Task+0xb2>
    7220:	eb c1       	rjmp	.+982    	; 0x75f8 <CDC_Task+0x496>
			  WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);		
		}
		else if (Command == 'V')
    7222:	86 35       	cpi	r24, 0x56	; 86
    7224:	21 f4       	brne	.+8      	; 0x722e <CDC_Task+0xcc>
		{
			WriteNextResponseByte('0' + BOOTLOADER_VERSION_MAJOR);
    7226:	81 e3       	ldi	r24, 0x31	; 49
    7228:	80 df       	rcall	.-256    	; 0x712a <WriteNextResponseByte>
			WriteNextResponseByte('0' + BOOTLOADER_VERSION_MINOR);
    722a:	80 e3       	ldi	r24, 0x30	; 48
    722c:	e4 c1       	rjmp	.+968    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 's')
    722e:	83 37       	cpi	r24, 0x73	; 115
    7230:	31 f4       	brne	.+12     	; 0x723e <CDC_Task+0xdc>
		{
			WriteNextResponseByte(AVR_SIGNATURE_3);		
    7232:	87 e8       	ldi	r24, 0x87	; 135
    7234:	7a df       	rcall	.-268    	; 0x712a <WriteNextResponseByte>
			WriteNextResponseByte(AVR_SIGNATURE_2);
    7236:	85 e9       	ldi	r24, 0x95	; 149
    7238:	78 df       	rcall	.-272    	; 0x712a <WriteNextResponseByte>
			WriteNextResponseByte(AVR_SIGNATURE_1);
    723a:	8e e1       	ldi	r24, 0x1E	; 30
    723c:	dc c1       	rjmp	.+952    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'b')
    723e:	82 36       	cpi	r24, 0x62	; 98
    7240:	31 f4       	brne	.+12     	; 0x724e <CDC_Task+0xec>
		{
			WriteNextResponseByte('Y');
    7242:	89 e5       	ldi	r24, 0x59	; 89
    7244:	72 df       	rcall	.-284    	; 0x712a <WriteNextResponseByte>
				
			/* Send block size to the host */
			WriteNextResponseByte(SPM_PAGESIZE >> 8);
    7246:	80 e0       	ldi	r24, 0x00	; 0
    7248:	70 df       	rcall	.-288    	; 0x712a <WriteNextResponseByte>
			WriteNextResponseByte(SPM_PAGESIZE & 0xFF);		
    724a:	80 e8       	ldi	r24, 0x80	; 128
    724c:	d4 c1       	rjmp	.+936    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'e')
    724e:	85 36       	cpi	r24, 0x65	; 101
    7250:	b9 f4       	brne	.+46     	; 0x7280 <CDC_Task+0x11e>
    7252:	e0 e0       	ldi	r30, 0x00	; 0
    7254:	f0 e0       	ldi	r31, 0x00	; 0
		{
			/* Clear the application section of flash */
			for (uint32_t CurrFlashAddress = 0; CurrFlashAddress < BOOT_START_ADDR; CurrFlashAddress++)
			{
				boot_page_erase(CurrFlashAddress);
    7256:	93 e0       	ldi	r25, 0x03	; 3
				boot_spm_busy_wait();
				boot_page_write(CurrFlashAddress);
    7258:	85 e0       	ldi	r24, 0x05	; 5
		else if (Command == 'e')
		{
			/* Clear the application section of flash */
			for (uint32_t CurrFlashAddress = 0; CurrFlashAddress < BOOT_START_ADDR; CurrFlashAddress++)
			{
				boot_page_erase(CurrFlashAddress);
    725a:	90 93 57 00 	sts	0x0057, r25
    725e:	e8 95       	spm
				boot_spm_busy_wait();
    7260:	07 b6       	in	r0, 0x37	; 55
    7262:	00 fc       	sbrc	r0, 0
    7264:	fd cf       	rjmp	.-6      	; 0x7260 <CDC_Task+0xfe>
				boot_page_write(CurrFlashAddress);
    7266:	80 93 57 00 	sts	0x0057, r24
    726a:	e8 95       	spm
				boot_spm_busy_wait();
    726c:	07 b6       	in	r0, 0x37	; 55
    726e:	00 fc       	sbrc	r0, 0
    7270:	fd cf       	rjmp	.-6      	; 0x726c <CDC_Task+0x10a>
    7272:	ef 57       	subi	r30, 0x7F	; 127
    7274:	ff 4f       	sbci	r31, 0xFF	; 255
			WriteNextResponseByte(SPM_PAGESIZE & 0xFF);		
		}
		else if (Command == 'e')
		{
			/* Clear the application section of flash */
			for (uint32_t CurrFlashAddress = 0; CurrFlashAddress < BOOT_START_ADDR; CurrFlashAddress++)
    7276:	20 e7       	ldi	r18, 0x70	; 112
    7278:	ef 35       	cpi	r30, 0x5F	; 95
    727a:	f2 07       	cpc	r31, r18
    727c:	71 f7       	brne	.-36     	; 0x725a <CDC_Task+0xf8>
    727e:	8d c1       	rjmp	.+794    	; 0x759a <CDC_Task+0x438>
			}
			
			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');		
		}
		else if (Command == 'l')
    7280:	8c 36       	cpi	r24, 0x6C	; 108
    7282:	51 f4       	brne	.+20     	; 0x7298 <CDC_Task+0x136>
		{
			/* Set the lock bits to those given by the host */
			boot_lock_bits_set(FetchNextCommandByte());
    7284:	36 df       	rcall	.-404    	; 0x70f2 <FetchNextCommandByte>
    7286:	80 95       	com	r24
    7288:	99 e0       	ldi	r25, 0x09	; 9
    728a:	e1 e0       	ldi	r30, 0x01	; 1
    728c:	f0 e0       	ldi	r31, 0x00	; 0
    728e:	08 2e       	mov	r0, r24
    7290:	90 93 57 00 	sts	0x0057, r25
    7294:	e8 95       	spm
    7296:	81 c1       	rjmp	.+770    	; 0x759a <CDC_Task+0x438>

			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');
		}
		else if (Command == 'r')
    7298:	82 37       	cpi	r24, 0x72	; 114
    729a:	39 f4       	brne	.+14     	; 0x72aa <CDC_Task+0x148>
		{
			WriteNextResponseByte(boot_lock_fuse_bits_get(GET_LOCK_BITS));		
    729c:	89 e0       	ldi	r24, 0x09	; 9
    729e:	e1 e0       	ldi	r30, 0x01	; 1
    72a0:	f0 e0       	ldi	r31, 0x00	; 0
    72a2:	80 93 57 00 	sts	0x0057, r24
    72a6:	84 91       	lpm	r24, Z+
    72a8:	a6 c1       	rjmp	.+844    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'F')
    72aa:	86 34       	cpi	r24, 0x46	; 70
    72ac:	39 f4       	brne	.+14     	; 0x72bc <CDC_Task+0x15a>
		{
			WriteNextResponseByte(boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS));
    72ae:	89 e0       	ldi	r24, 0x09	; 9
    72b0:	e0 e0       	ldi	r30, 0x00	; 0
    72b2:	f0 e0       	ldi	r31, 0x00	; 0
    72b4:	80 93 57 00 	sts	0x0057, r24
    72b8:	84 91       	lpm	r24, Z+
    72ba:	9d c1       	rjmp	.+826    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'N')
    72bc:	8e 34       	cpi	r24, 0x4E	; 78
    72be:	39 f4       	brne	.+14     	; 0x72ce <CDC_Task+0x16c>
		{
			WriteNextResponseByte(boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS));		
    72c0:	89 e0       	ldi	r24, 0x09	; 9
    72c2:	e3 e0       	ldi	r30, 0x03	; 3
    72c4:	f0 e0       	ldi	r31, 0x00	; 0
    72c6:	80 93 57 00 	sts	0x0057, r24
    72ca:	84 91       	lpm	r24, Z+
    72cc:	94 c1       	rjmp	.+808    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'Q')
    72ce:	81 35       	cpi	r24, 0x51	; 81
    72d0:	39 f4       	brne	.+14     	; 0x72e0 <CDC_Task+0x17e>
		{
			WriteNextResponseByte(boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS));		
    72d2:	89 e0       	ldi	r24, 0x09	; 9
    72d4:	e2 e0       	ldi	r30, 0x02	; 2
    72d6:	f0 e0       	ldi	r31, 0x00	; 0
    72d8:	80 93 57 00 	sts	0x0057, r24
    72dc:	84 91       	lpm	r24, Z+
    72de:	8b c1       	rjmp	.+790    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'C')
    72e0:	83 34       	cpi	r24, 0x43	; 67
    72e2:	71 f4       	brne	.+28     	; 0x7300 <CDC_Task+0x19e>
		{			
			/* Write the high byte to the current flash page */
			boot_page_fill(CurrAddress, FetchNextCommandByte());
    72e4:	00 91 92 01 	lds	r16, 0x0192
    72e8:	10 91 93 01 	lds	r17, 0x0193
    72ec:	02 df       	rcall	.-508    	; 0x70f2 <FetchNextCommandByte>
    72ee:	90 e0       	ldi	r25, 0x00	; 0
    72f0:	21 e0       	ldi	r18, 0x01	; 1
    72f2:	f8 01       	movw	r30, r16
    72f4:	0c 01       	movw	r0, r24
    72f6:	20 93 57 00 	sts	0x0057, r18
    72fa:	e8 95       	spm
    72fc:	11 24       	eor	r1, r1
    72fe:	4d c1       	rjmp	.+666    	; 0x759a <CDC_Task+0x438>

			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');		
		}
		else if (Command == 'c')
    7300:	83 36       	cpi	r24, 0x63	; 99
    7302:	79 f4       	brne	.+30     	; 0x7322 <CDC_Task+0x1c0>
		{			
			/* Write the low byte to the current flash page */
			boot_page_fill(CurrAddress | 1, FetchNextCommandByte());
    7304:	00 91 92 01 	lds	r16, 0x0192
    7308:	10 91 93 01 	lds	r17, 0x0193
    730c:	01 60       	ori	r16, 0x01	; 1
    730e:	f1 de       	rcall	.-542    	; 0x70f2 <FetchNextCommandByte>
    7310:	90 e0       	ldi	r25, 0x00	; 0
    7312:	21 e0       	ldi	r18, 0x01	; 1
    7314:	f8 01       	movw	r30, r16
    7316:	0c 01       	movw	r0, r24
    7318:	20 93 57 00 	sts	0x0057, r18
    731c:	e8 95       	spm
    731e:	11 24       	eor	r1, r1
    7320:	29 c1       	rjmp	.+594    	; 0x7574 <CDC_Task+0x412>
			CurrAddress += 2;

			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');		
		}
		else if (Command == 'm')
    7322:	8d 36       	cpi	r24, 0x6D	; 109
    7324:	61 f4       	brne	.+24     	; 0x733e <CDC_Task+0x1dc>
		{
			/* Commit the flash page to memory */
			boot_page_write(CurrAddress);
    7326:	e0 91 92 01 	lds	r30, 0x0192
    732a:	f0 91 93 01 	lds	r31, 0x0193
    732e:	85 e0       	ldi	r24, 0x05	; 5
    7330:	80 93 57 00 	sts	0x0057, r24
    7334:	e8 95       	spm
			
			/* Wait until write operation has completed */
			boot_spm_busy_wait();
    7336:	07 b6       	in	r0, 0x37	; 55
    7338:	00 fc       	sbrc	r0, 0
    733a:	fd cf       	rjmp	.-6      	; 0x7336 <CDC_Task+0x1d4>
    733c:	2e c1       	rjmp	.+604    	; 0x759a <CDC_Task+0x438>

			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');		
		}
		else if ((Command == 'B') || (Command == 'g'))
    733e:	82 34       	cpi	r24, 0x42	; 66
    7340:	19 f0       	breq	.+6      	; 0x7348 <CDC_Task+0x1e6>
    7342:	87 36       	cpi	r24, 0x67	; 103
    7344:	09 f0       	breq	.+2      	; 0x7348 <CDC_Task+0x1e6>
    7346:	f0 c0       	rjmp	.+480    	; 0x7528 <CDC_Task+0x3c6>
	char     MemoryType;
	
	bool     HighByte = false;
	uint8_t  LowByte  = 0;
	
	BlockSize  = (FetchNextCommandByte() << 8);
    7348:	d4 de       	rcall	.-600    	; 0x70f2 <FetchNextCommandByte>
    734a:	08 2f       	mov	r16, r24
	BlockSize |=  FetchNextCommandByte();
    734c:	d2 de       	rcall	.-604    	; 0x70f2 <FetchNextCommandByte>
    734e:	f8 2e       	mov	r15, r24
	
	MemoryType =  FetchNextCommandByte();
    7350:	d0 de       	rcall	.-608    	; 0x70f2 <FetchNextCommandByte>
    7352:	a8 2e       	mov	r10, r24

	if ((MemoryType != 'E') && (MemoryType != 'F'))
    7354:	85 54       	subi	r24, 0x45	; 69
    7356:	82 30       	cpi	r24, 0x02	; 2
    7358:	08 f0       	brcs	.+2      	; 0x735c <CDC_Task+0x1fa>
    735a:	4c c1       	rjmp	.+664    	; 0x75f4 <CDC_Task+0x492>
	char     MemoryType;
	
	bool     HighByte = false;
	uint8_t  LowByte  = 0;
	
	BlockSize  = (FetchNextCommandByte() << 8);
    735c:	90 2f       	mov	r25, r16
    735e:	80 e0       	ldi	r24, 0x00	; 0
	BlockSize |=  FetchNextCommandByte();
    7360:	cf 2d       	mov	r28, r15
    7362:	d0 e0       	ldi	r29, 0x00	; 0
    7364:	c8 2b       	or	r28, r24
    7366:	d9 2b       	or	r29, r25
		
		return;
	}

	/* Check if command is to read memory */
	if (Command == 'g')
    7368:	17 36       	cpi	r17, 0x67	; 103
    736a:	09 f0       	breq	.+2      	; 0x736e <CDC_Task+0x20c>
    736c:	57 c0       	rjmp	.+174    	; 0x741c <CDC_Task+0x2ba>
	{
		/* Re-enable RWW section */
		boot_rww_enable();
    736e:	81 e1       	ldi	r24, 0x11	; 17
    7370:	80 93 57 00 	sts	0x0057, r24
    7374:	e8 95       	spm
    7376:	10 e0       	ldi	r17, 0x00	; 0
				
				/* If both bytes in current word have been read, increment the address counter */
				if (HighByte)
				  CurrAddress += 2;
				
				HighByte = !HighByte;
    7378:	01 e0       	ldi	r16, 0x01	; 1
    737a:	4c c0       	rjmp	.+152    	; 0x7414 <CDC_Task+0x2b2>
		/* Re-enable RWW section */
		boot_rww_enable();

		while (BlockSize--)
		{
			if (MemoryType == 'F')
    737c:	f6 e4       	ldi	r31, 0x46	; 70
    737e:	af 16       	cp	r10, r31
    7380:	11 f5       	brne	.+68     	; 0x73c6 <CDC_Task+0x264>
			{
				/* Read the next FLASH byte from the current FLASH page */
				#if (FLASHEND > 0xFFFF)
				WriteNextResponseByte(pgm_read_byte_far(CurrAddress | HighByte));
				#else
				WriteNextResponseByte(pgm_read_byte(CurrAddress | HighByte));					
    7382:	e1 2f       	mov	r30, r17
    7384:	f0 e0       	ldi	r31, 0x00	; 0
    7386:	80 91 92 01 	lds	r24, 0x0192
    738a:	90 91 93 01 	lds	r25, 0x0193
    738e:	e8 2b       	or	r30, r24
    7390:	f9 2b       	or	r31, r25
    7392:	e4 91       	lpm	r30, Z+
    7394:	8e 2f       	mov	r24, r30
    7396:	c9 de       	rcall	.-622    	; 0x712a <WriteNextResponseByte>
				#endif
				
				/* If both bytes in current word have been read, increment the address counter */
				if (HighByte)
    7398:	11 23       	and	r17, r17
    739a:	99 f0       	breq	.+38     	; 0x73c2 <CDC_Task+0x260>
				  CurrAddress += 2;
    739c:	80 91 92 01 	lds	r24, 0x0192
    73a0:	90 91 93 01 	lds	r25, 0x0193
    73a4:	a0 91 94 01 	lds	r26, 0x0194
    73a8:	b0 91 95 01 	lds	r27, 0x0195
    73ac:	02 96       	adiw	r24, 0x02	; 2
    73ae:	a1 1d       	adc	r26, r1
    73b0:	b1 1d       	adc	r27, r1
    73b2:	80 93 92 01 	sts	0x0192, r24
    73b6:	90 93 93 01 	sts	0x0193, r25
    73ba:	a0 93 94 01 	sts	0x0194, r26
    73be:	b0 93 95 01 	sts	0x0195, r27
				
				HighByte = !HighByte;
    73c2:	10 27       	eor	r17, r16
    73c4:	26 c0       	rjmp	.+76     	; 0x7412 <CDC_Task+0x2b0>
			}
			else
			{
				/* Read the next EEPROM byte into the endpoint */
				WriteNextResponseByte(eeprom_read_byte((uint8_t*)(uint16_t)(CurrAddress >> 1)));
    73c6:	80 91 92 01 	lds	r24, 0x0192
    73ca:	90 91 93 01 	lds	r25, 0x0193
    73ce:	a0 91 94 01 	lds	r26, 0x0194
    73d2:	b0 91 95 01 	lds	r27, 0x0195
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    73d6:	f9 99       	sbic	0x1f, 1	; 31
    73d8:	fe cf       	rjmp	.-4      	; 0x73d6 <CDC_Task+0x274>
    73da:	b6 95       	lsr	r27
    73dc:	a7 95       	ror	r26
    73de:	97 95       	ror	r25
    73e0:	87 95       	ror	r24
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    73e2:	92 bd       	out	0x22, r25	; 34
    73e4:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    73e6:	f8 9a       	sbi	0x1f, 0	; 31
    73e8:	80 b5       	in	r24, 0x20	; 32
    73ea:	9f de       	rcall	.-706    	; 0x712a <WriteNextResponseByte>

				/* Increment the address counter after use */
				CurrAddress += 2;
    73ec:	80 91 92 01 	lds	r24, 0x0192
    73f0:	90 91 93 01 	lds	r25, 0x0193
    73f4:	a0 91 94 01 	lds	r26, 0x0194
    73f8:	b0 91 95 01 	lds	r27, 0x0195
    73fc:	02 96       	adiw	r24, 0x02	; 2
    73fe:	a1 1d       	adc	r26, r1
    7400:	b1 1d       	adc	r27, r1
    7402:	80 93 92 01 	sts	0x0192, r24
    7406:	90 93 93 01 	sts	0x0193, r25
    740a:	a0 93 94 01 	sts	0x0194, r26
    740e:	b0 93 95 01 	sts	0x0195, r27
    7412:	21 97       	sbiw	r28, 0x01	; 1
	if (Command == 'g')
	{
		/* Re-enable RWW section */
		boot_rww_enable();

		while (BlockSize--)
    7414:	20 97       	sbiw	r28, 0x00	; 0
    7416:	09 f0       	breq	.+2      	; 0x741a <CDC_Task+0x2b8>
    7418:	b1 cf       	rjmp	.-158    	; 0x737c <CDC_Task+0x21a>
    741a:	ee c0       	rjmp	.+476    	; 0x75f8 <CDC_Task+0x496>
			}			
		}
	}
	else
	{
		uint32_t PageStartAddress = CurrAddress;
    741c:	60 90 92 01 	lds	r6, 0x0192
    7420:	70 90 93 01 	lds	r7, 0x0193
    7424:	80 90 94 01 	lds	r8, 0x0194
    7428:	90 90 95 01 	lds	r9, 0x0195

		if (MemoryType == 'F')
    742c:	26 e4       	ldi	r18, 0x46	; 70
    742e:	a2 16       	cp	r10, r18
    7430:	09 f0       	breq	.+2      	; 0x7434 <CDC_Task+0x2d2>
    7432:	66 c0       	rjmp	.+204    	; 0x7500 <CDC_Task+0x39e>
		{
			boot_page_erase(PageStartAddress);
    7434:	83 e0       	ldi	r24, 0x03	; 3
    7436:	f3 01       	movw	r30, r6
    7438:	80 93 57 00 	sts	0x0057, r24
    743c:	e8 95       	spm
			boot_spm_busy_wait();
    743e:	07 b6       	in	r0, 0x37	; 55
    7440:	00 fc       	sbrc	r0, 0
    7442:	fd cf       	rjmp	.-6      	; 0x743e <CDC_Task+0x2dc>
    7444:	5d c0       	rjmp	.+186    	; 0x7500 <CDC_Task+0x39e>
		}
		
		while (BlockSize--)
		{
			if (MemoryType == 'F')
    7446:	f6 e4       	ldi	r31, 0x46	; 70
    7448:	af 16       	cp	r10, r31
    744a:	69 f5       	brne	.+90     	; 0x74a6 <CDC_Task+0x344>
			{	
				/* If both bytes in current word have been written, increment the address counter */
				if (HighByte)
    744c:	bb 20       	and	r11, r11
    744e:	31 f1       	breq	.+76     	; 0x749c <CDC_Task+0x33a>
				{
					/* Write the next FLASH word to the current FLASH page */
					boot_page_fill(CurrAddress, ((FetchNextCommandByte() << 8) | LowByte));
    7450:	00 91 92 01 	lds	r16, 0x0192
    7454:	10 91 93 01 	lds	r17, 0x0193
    7458:	4c de       	rcall	.-872    	; 0x70f2 <FetchNextCommandByte>
    745a:	d8 2e       	mov	r13, r24
    745c:	cc 24       	eor	r12, r12
    745e:	85 2d       	mov	r24, r5
    7460:	90 e0       	ldi	r25, 0x00	; 0
    7462:	8c 29       	or	r24, r12
    7464:	9d 29       	or	r25, r13
    7466:	f8 01       	movw	r30, r16
    7468:	0c 01       	movw	r0, r24
    746a:	40 92 57 00 	sts	0x0057, r4
    746e:	e8 95       	spm
    7470:	11 24       	eor	r1, r1

					/* Increment the address counter after use */
					CurrAddress += 2;
    7472:	80 91 92 01 	lds	r24, 0x0192
    7476:	90 91 93 01 	lds	r25, 0x0193
    747a:	a0 91 94 01 	lds	r26, 0x0194
    747e:	b0 91 95 01 	lds	r27, 0x0195
    7482:	02 96       	adiw	r24, 0x02	; 2
    7484:	a1 1d       	adc	r26, r1
    7486:	b1 1d       	adc	r27, r1
    7488:	80 93 92 01 	sts	0x0192, r24
    748c:	90 93 93 01 	sts	0x0193, r25
    7490:	a0 93 94 01 	sts	0x0194, r26
    7494:	b0 93 95 01 	sts	0x0195, r27
    7498:	bb 24       	eor	r11, r11
    749a:	30 c0       	rjmp	.+96     	; 0x74fc <CDC_Task+0x39a>

					HighByte = false;
				}
				else
				{
					LowByte = FetchNextCommandByte();
    749c:	2a de       	rcall	.-940    	; 0x70f2 <FetchNextCommandByte>
    749e:	58 2e       	mov	r5, r24
    74a0:	bb 24       	eor	r11, r11
    74a2:	b3 94       	inc	r11
    74a4:	2b c0       	rjmp	.+86     	; 0x74fc <CDC_Task+0x39a>
				}
			}
			else
			{
				/* Write the next EEPROM byte from the endpoint */
				eeprom_write_byte((uint8_t*)(uint16_t)(CurrAddress >> 1), FetchNextCommandByte());					
    74a6:	e0 90 92 01 	lds	r14, 0x0192
    74aa:	f0 90 93 01 	lds	r15, 0x0193
    74ae:	00 91 94 01 	lds	r16, 0x0194
    74b2:	10 91 95 01 	lds	r17, 0x0195
    74b6:	1d de       	rcall	.-966    	; 0x70f2 <FetchNextCommandByte>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    74b8:	f9 99       	sbic	0x1f, 1	; 31
    74ba:	fe cf       	rjmp	.-4      	; 0x74b8 <CDC_Task+0x356>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    74bc:	1f ba       	out	0x1f, r1	; 31
    74be:	16 95       	lsr	r17
    74c0:	07 95       	ror	r16
    74c2:	f7 94       	ror	r15
    74c4:	e7 94       	ror	r14
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    74c6:	f2 bc       	out	0x22, r15	; 34
    74c8:	e1 bc       	out	0x21, r14	; 33
#endif
    EEDR = __value;
    74ca:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    74cc:	0f b6       	in	r0, 0x3f	; 63
    74ce:	f8 94       	cli
    74d0:	fa 9a       	sbi	0x1f, 2	; 31
    74d2:	f9 9a       	sbi	0x1f, 1	; 31
    74d4:	0f be       	out	0x3f, r0	; 63

				/* Increment the address counter after use */
				CurrAddress += 2;
    74d6:	80 91 92 01 	lds	r24, 0x0192
    74da:	90 91 93 01 	lds	r25, 0x0193
    74de:	a0 91 94 01 	lds	r26, 0x0194
    74e2:	b0 91 95 01 	lds	r27, 0x0195
    74e6:	02 96       	adiw	r24, 0x02	; 2
    74e8:	a1 1d       	adc	r26, r1
    74ea:	b1 1d       	adc	r27, r1
    74ec:	80 93 92 01 	sts	0x0192, r24
    74f0:	90 93 93 01 	sts	0x0193, r25
    74f4:	a0 93 94 01 	sts	0x0194, r26
    74f8:	b0 93 95 01 	sts	0x0195, r27
    74fc:	21 97       	sbiw	r28, 0x01	; 1
    74fe:	04 c0       	rjmp	.+8      	; 0x7508 <CDC_Task+0x3a6>
    7500:	55 24       	eor	r5, r5
    7502:	bb 24       	eor	r11, r11

					HighByte = false;
				}
				else
				{
					LowByte = FetchNextCommandByte();
    7504:	44 24       	eor	r4, r4
    7506:	43 94       	inc	r4
		{
			boot_page_erase(PageStartAddress);
			boot_spm_busy_wait();
		}
		
		while (BlockSize--)
    7508:	20 97       	sbiw	r28, 0x00	; 0
    750a:	09 f0       	breq	.+2      	; 0x750e <CDC_Task+0x3ac>
    750c:	9c cf       	rjmp	.-200    	; 0x7446 <CDC_Task+0x2e4>
				CurrAddress += 2;
			}
		}

		/* If in FLASH programming mode, commit the page after writing */
		if (MemoryType == 'F')
    750e:	f6 e4       	ldi	r31, 0x46	; 70
    7510:	af 16       	cp	r10, r31
    7512:	09 f0       	breq	.+2      	; 0x7516 <CDC_Task+0x3b4>
    7514:	42 c0       	rjmp	.+132    	; 0x759a <CDC_Task+0x438>
		{
			/* Commit the flash page to memory */
			boot_page_write(PageStartAddress);
    7516:	85 e0       	ldi	r24, 0x05	; 5
    7518:	f3 01       	movw	r30, r6
    751a:	80 93 57 00 	sts	0x0057, r24
    751e:	e8 95       	spm
			
			/* Wait until write operation has completed */
			boot_spm_busy_wait();
    7520:	07 b6       	in	r0, 0x37	; 55
    7522:	00 fc       	sbrc	r0, 0
    7524:	fd cf       	rjmp	.-6      	; 0x7520 <CDC_Task+0x3be>
    7526:	39 c0       	rjmp	.+114    	; 0x759a <CDC_Task+0x438>
		else if ((Command == 'B') || (Command == 'g'))
		{
			/* Delegate the block write/read to a separate function for clarity */
			ReadWriteMemoryBlock(Command);
		}
		else if (Command == 'R')
    7528:	82 35       	cpi	r24, 0x52	; 82
    752a:	51 f4       	brne	.+20     	; 0x7540 <CDC_Task+0x3de>
		{
			#if (FLASHEND > 0xFFFF)
			uint16_t ProgramWord = pgm_read_word_far(CurrAddress);
			#else
			uint16_t ProgramWord = pgm_read_word(CurrAddress);			
    752c:	e0 91 92 01 	lds	r30, 0x0192
    7530:	f0 91 93 01 	lds	r31, 0x0193
    7534:	05 91       	lpm	r16, Z+
    7536:	14 91       	lpm	r17, Z+
			#endif
			
			WriteNextResponseByte(ProgramWord >> 8);
    7538:	81 2f       	mov	r24, r17
    753a:	f7 dd       	rcall	.-1042   	; 0x712a <WriteNextResponseByte>
			WriteNextResponseByte(ProgramWord & 0xFF);
    753c:	80 2f       	mov	r24, r16
    753e:	5b c0       	rjmp	.+182    	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'D')
    7540:	84 34       	cpi	r24, 0x44	; 68
    7542:	69 f5       	brne	.+90     	; 0x759e <CDC_Task+0x43c>
		{
			/* Read the byte from the endpoint and write it to the EEPROM */
			eeprom_write_byte((uint8_t*)((uint16_t)(CurrAddress >> 1)), FetchNextCommandByte());
    7544:	e0 90 92 01 	lds	r14, 0x0192
    7548:	f0 90 93 01 	lds	r15, 0x0193
    754c:	00 91 94 01 	lds	r16, 0x0194
    7550:	10 91 95 01 	lds	r17, 0x0195
    7554:	ce dd       	rcall	.-1124   	; 0x70f2 <FetchNextCommandByte>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    7556:	f9 99       	sbic	0x1f, 1	; 31
    7558:	fe cf       	rjmp	.-4      	; 0x7556 <CDC_Task+0x3f4>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    755a:	1f ba       	out	0x1f, r1	; 31
    755c:	16 95       	lsr	r17
    755e:	07 95       	ror	r16
    7560:	f7 94       	ror	r15
    7562:	e7 94       	ror	r14
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    7564:	f2 bc       	out	0x22, r15	; 34
    7566:	e1 bc       	out	0x21, r14	; 33
#endif
    EEDR = __value;
    7568:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    756a:	0f b6       	in	r0, 0x3f	; 63
    756c:	f8 94       	cli
    756e:	fa 9a       	sbi	0x1f, 2	; 31
    7570:	f9 9a       	sbi	0x1f, 1	; 31
    7572:	0f be       	out	0x3f, r0	; 63
			
			/* Increment the address after use */			
			CurrAddress += 2;
    7574:	80 91 92 01 	lds	r24, 0x0192
    7578:	90 91 93 01 	lds	r25, 0x0193
    757c:	a0 91 94 01 	lds	r26, 0x0194
    7580:	b0 91 95 01 	lds	r27, 0x0195
    7584:	02 96       	adiw	r24, 0x02	; 2
    7586:	a1 1d       	adc	r26, r1
    7588:	b1 1d       	adc	r27, r1
    758a:	80 93 92 01 	sts	0x0192, r24
    758e:	90 93 93 01 	sts	0x0193, r25
    7592:	a0 93 94 01 	sts	0x0194, r26
    7596:	b0 93 95 01 	sts	0x0195, r27
	
			/* Send confirmation byte back to the host */
			WriteNextResponseByte('\r');		
    759a:	8d e0       	ldi	r24, 0x0D	; 13
    759c:	2c c0       	rjmp	.+88     	; 0x75f6 <CDC_Task+0x494>
		}
		else if (Command == 'd')
    759e:	84 36       	cpi	r24, 0x64	; 100
    75a0:	39 f5       	brne	.+78     	; 0x75f0 <CDC_Task+0x48e>
		{
			/* Read the EEPROM byte and write it to the endpoint */
			WriteNextResponseByte(eeprom_read_byte((uint8_t*)((uint16_t)(CurrAddress >> 1))));
    75a2:	80 91 92 01 	lds	r24, 0x0192
    75a6:	90 91 93 01 	lds	r25, 0x0193
    75aa:	a0 91 94 01 	lds	r26, 0x0194
    75ae:	b0 91 95 01 	lds	r27, 0x0195
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    75b2:	f9 99       	sbic	0x1f, 1	; 31
    75b4:	fe cf       	rjmp	.-4      	; 0x75b2 <CDC_Task+0x450>
    75b6:	b6 95       	lsr	r27
    75b8:	a7 95       	ror	r26
    75ba:	97 95       	ror	r25
    75bc:	87 95       	ror	r24
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    75be:	92 bd       	out	0x22, r25	; 34
    75c0:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    75c2:	f8 9a       	sbi	0x1f, 0	; 31
    75c4:	80 b5       	in	r24, 0x20	; 32
    75c6:	b1 dd       	rcall	.-1182   	; 0x712a <WriteNextResponseByte>

			/* Increment the address after use */
			CurrAddress += 2;
    75c8:	80 91 92 01 	lds	r24, 0x0192
    75cc:	90 91 93 01 	lds	r25, 0x0193
    75d0:	a0 91 94 01 	lds	r26, 0x0194
    75d4:	b0 91 95 01 	lds	r27, 0x0195
    75d8:	02 96       	adiw	r24, 0x02	; 2
    75da:	a1 1d       	adc	r26, r1
    75dc:	b1 1d       	adc	r27, r1
    75de:	80 93 92 01 	sts	0x0192, r24
    75e2:	90 93 93 01 	sts	0x0193, r25
    75e6:	a0 93 94 01 	sts	0x0194, r26
    75ea:	b0 93 95 01 	sts	0x0195, r27
    75ee:	04 c0       	rjmp	.+8      	; 0x75f8 <CDC_Task+0x496>
		}
		else if (Command == 27)
    75f0:	8b 31       	cpi	r24, 0x1B	; 27
    75f2:	11 f0       	breq	.+4      	; 0x75f8 <CDC_Task+0x496>
			/* Escape is sync, ignore */
		}
		else
		{
			/* Unknown command, return fail code */
			WriteNextResponseByte('?');
    75f4:	8f e3       	ldi	r24, 0x3F	; 63
    75f6:	99 dd       	rcall	.-1230   	; 0x712a <WriteNextResponseByte>
		}

		/* Select the IN endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPNUM);
    75f8:	81 e0       	ldi	r24, 0x01	; 1
    75fa:	80 93 e9 00 	sts	0x00E9, r24

		/* Remember if the endpoint is completely full before clearing it */
		bool IsEndpointFull = !(Endpoint_IsReadWriteAllowed());
    75fe:	20 91 e8 00 	lds	r18, 0x00E8

		/* Send the endpoint data to the host */
		Endpoint_ClearIN();
    7602:	80 91 e8 00 	lds	r24, 0x00E8
    7606:	98 2f       	mov	r25, r24
    7608:	9e 7f       	andi	r25, 0xFE	; 254
    760a:	90 93 e8 00 	sts	0x00E8, r25
    760e:	8f 77       	andi	r24, 0x7F	; 127
    7610:	80 93 e8 00 	sts	0x00E8, r24
		
		/* If a full endpoint's worth of data was sent, we need to send an empty packet afterwards to signal end of transfer */
		if (IsEndpointFull)
    7614:	25 ff       	sbrs	r18, 5
    7616:	04 c0       	rjmp	.+8      	; 0x7620 <CDC_Task+0x4be>
    7618:	14 c0       	rjmp	.+40     	; 0x7642 <CDC_Task+0x4e0>
		{
			while (!(Endpoint_IsINReady()))
			{				
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    761a:	8e b3       	in	r24, 0x1e	; 30
    761c:	88 23       	and	r24, r24
    761e:	09 f1       	breq	.+66     	; 0x7662 <CDC_Task+0x500>
		Endpoint_ClearIN();
		
		/* If a full endpoint's worth of data was sent, we need to send an empty packet afterwards to signal end of transfer */
		if (IsEndpointFull)
		{
			while (!(Endpoint_IsINReady()))
    7620:	80 91 e8 00 	lds	r24, 0x00E8
    7624:	80 ff       	sbrs	r24, 0
    7626:	f9 cf       	rjmp	.-14     	; 0x761a <CDC_Task+0x4b8>
			{				
				if (USB_DeviceState == DEVICE_STATE_Unattached)
				  return;
			}

			Endpoint_ClearIN();
    7628:	80 91 e8 00 	lds	r24, 0x00E8
    762c:	98 2f       	mov	r25, r24
    762e:	9e 7f       	andi	r25, 0xFE	; 254
    7630:	90 93 e8 00 	sts	0x00E8, r25
    7634:	8f 77       	andi	r24, 0x7F	; 127
    7636:	80 93 e8 00 	sts	0x00E8, r24
    763a:	03 c0       	rjmp	.+6      	; 0x7642 <CDC_Task+0x4e0>
		}

		/* Wait until the data has been sent to the host */
		while (!(Endpoint_IsINReady()))
		{				
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    763c:	8e b3       	in	r24, 0x1e	; 30
    763e:	88 23       	and	r24, r24
    7640:	81 f0       	breq	.+32     	; 0x7662 <CDC_Task+0x500>

			Endpoint_ClearIN();
		}

		/* Wait until the data has been sent to the host */
		while (!(Endpoint_IsINReady()))
    7642:	80 91 e8 00 	lds	r24, 0x00E8
    7646:	80 ff       	sbrs	r24, 0
    7648:	f9 cf       	rjmp	.-14     	; 0x763c <CDC_Task+0x4da>
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}
		
		/* Select the OUT endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPNUM);
    764a:	82 e0       	ldi	r24, 0x02	; 2
    764c:	80 93 e9 00 	sts	0x00E9, r24

		/* Acknowledge the command from the host */
		Endpoint_ClearOUT();
    7650:	80 91 e8 00 	lds	r24, 0x00E8
    7654:	98 2f       	mov	r25, r24
    7656:	9b 7f       	andi	r25, 0xFB	; 251
    7658:	90 93 e8 00 	sts	0x00E8, r25
    765c:	8f 77       	andi	r24, 0x7F	; 127
    765e:	80 93 e8 00 	sts	0x00E8, r24
	}
	
}
    7662:	df 91       	pop	r29
    7664:	cf 91       	pop	r28
    7666:	1f 91       	pop	r17
    7668:	0f 91       	pop	r16
    766a:	ff 90       	pop	r15
    766c:	ef 90       	pop	r14
    766e:	df 90       	pop	r13
    7670:	cf 90       	pop	r12
    7672:	bf 90       	pop	r11
    7674:	af 90       	pop	r10
    7676:	9f 90       	pop	r9
    7678:	8f 90       	pop	r8
    767a:	7f 90       	pop	r7
    767c:	6f 90       	pop	r6
    767e:	5f 90       	pop	r5
    7680:	4f 90       	pop	r4
    7682:	08 95       	ret

00007684 <EVENT_USB_Device_UnhandledControlRequest>:
void EVENT_USB_Device_UnhandledControlRequest(void)
{
	uint8_t* LineCodingData = (uint8_t*)&LineCoding;

	/* Process CDC specific control requests */
	switch (USB_ControlRequest.bRequest)
    7684:	80 91 99 01 	lds	r24, 0x0199
    7688:	81 32       	cpi	r24, 0x21	; 33
    768a:	39 f0       	breq	.+14     	; 0x769a <EVENT_USB_Device_UnhandledControlRequest+0x16>
    768c:	82 32       	cpi	r24, 0x22	; 34
    768e:	09 f4       	brne	.+2      	; 0x7692 <EVENT_USB_Device_UnhandledControlRequest+0xe>
    7690:	40 c0       	rjmp	.+128    	; 0x7712 <EVENT_USB_Device_UnhandledControlRequest+0x8e>
    7692:	80 32       	cpi	r24, 0x20	; 32
    7694:	09 f0       	breq	.+2      	; 0x7698 <EVENT_USB_Device_UnhandledControlRequest+0x14>
    7696:	47 c0       	rjmp	.+142    	; 0x7726 <EVENT_USB_Device_UnhandledControlRequest+0xa2>
    7698:	18 c0       	rjmp	.+48     	; 0x76ca <EVENT_USB_Device_UnhandledControlRequest+0x46>
	{
		case REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    769a:	80 91 98 01 	lds	r24, 0x0198
    769e:	81 3a       	cpi	r24, 0xA1	; 161
    76a0:	09 f0       	breq	.+2      	; 0x76a4 <EVENT_USB_Device_UnhandledControlRequest+0x20>
    76a2:	41 c0       	rjmp	.+130    	; 0x7726 <EVENT_USB_Device_UnhandledControlRequest+0xa2>
			{
				Endpoint_ClearSETUP();
    76a4:	80 91 e8 00 	lds	r24, 0x00E8
    76a8:	87 7f       	andi	r24, 0xF7	; 247
    76aa:	80 93 e8 00 	sts	0x00E8, r24
    76ae:	e8 e0       	ldi	r30, 0x08	; 8
    76b0:	f1 e0       	ldi	r31, 0x01	; 1

				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
				  Endpoint_Write_Byte(*(LineCodingData++));	
    76b2:	81 91       	ld	r24, Z+
    76b4:	80 93 f1 00 	sts	0x00F1, r24
		case REQ_GetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();

				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
    76b8:	81 e0       	ldi	r24, 0x01	; 1
    76ba:	ef 30       	cpi	r30, 0x0F	; 15
    76bc:	f8 07       	cpc	r31, r24
    76be:	c9 f7       	brne	.-14     	; 0x76b2 <EVENT_USB_Device_UnhandledControlRequest+0x2e>
				  Endpoint_Write_Byte(*(LineCodingData++));	
				
				Endpoint_ClearIN();
    76c0:	80 91 e8 00 	lds	r24, 0x00E8
    76c4:	98 2f       	mov	r25, r24
    76c6:	9e 7f       	andi	r25, 0xFE	; 254
    76c8:	1e c0       	rjmp	.+60     	; 0x7706 <EVENT_USB_Device_UnhandledControlRequest+0x82>
				Endpoint_ClearStatusStage();
			}
			
			break;
		case REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    76ca:	80 91 98 01 	lds	r24, 0x0198
    76ce:	81 32       	cpi	r24, 0x21	; 33
    76d0:	51 f5       	brne	.+84     	; 0x7726 <EVENT_USB_Device_UnhandledControlRequest+0xa2>
			{
				Endpoint_ClearSETUP();
    76d2:	80 91 e8 00 	lds	r24, 0x00E8
    76d6:	87 7f       	andi	r24, 0xF7	; 247
    76d8:	80 93 e8 00 	sts	0x00E8, r24
    76dc:	03 c0       	rjmp	.+6      	; 0x76e4 <EVENT_USB_Device_UnhandledControlRequest+0x60>

				while (!(Endpoint_IsOUTReceived()))
				{				
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    76de:	8e b3       	in	r24, 0x1e	; 30
    76e0:	88 23       	and	r24, r24
    76e2:	09 f1       	breq	.+66     	; 0x7726 <EVENT_USB_Device_UnhandledControlRequest+0xa2>
		case REQ_SetLineEncoding:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSETUP();

				while (!(Endpoint_IsOUTReceived()))
    76e4:	80 91 e8 00 	lds	r24, 0x00E8
    76e8:	82 ff       	sbrs	r24, 2
    76ea:	f9 cf       	rjmp	.-14     	; 0x76de <EVENT_USB_Device_UnhandledControlRequest+0x5a>
    76ec:	e8 e0       	ldi	r30, 0x08	; 8
    76ee:	f1 e0       	ldi	r31, 0x01	; 1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    76f0:	80 91 f1 00 	lds	r24, 0x00F1
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}
			
				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
				  *(LineCodingData++) = Endpoint_Read_Byte();
    76f4:	81 93       	st	Z+, r24
				{				
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}
			
				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
    76f6:	81 e0       	ldi	r24, 0x01	; 1
    76f8:	ef 30       	cpi	r30, 0x0F	; 15
    76fa:	f8 07       	cpc	r31, r24
    76fc:	c9 f7       	brne	.-14     	; 0x76f0 <EVENT_USB_Device_UnhandledControlRequest+0x6c>
				  *(LineCodingData++) = Endpoint_Read_Byte();

				Endpoint_ClearOUT();
    76fe:	80 91 e8 00 	lds	r24, 0x00E8
    7702:	98 2f       	mov	r25, r24
    7704:	9b 7f       	andi	r25, 0xFB	; 251
    7706:	90 93 e8 00 	sts	0x00E8, r25
    770a:	8f 77       	andi	r24, 0x7F	; 127
    770c:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_ClearStatusStage();
    7710:	d2 c1       	rjmp	.+932    	; 0x7ab6 <Endpoint_ClearStatusStage>
			}
	
			break;
		case REQ_SetControlLineState:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    7712:	80 91 98 01 	lds	r24, 0x0198
    7716:	81 32       	cpi	r24, 0x21	; 33
    7718:	31 f4       	brne	.+12     	; 0x7726 <EVENT_USB_Device_UnhandledControlRequest+0xa2>
			{
				Endpoint_ClearSETUP();
    771a:	80 91 e8 00 	lds	r24, 0x00E8
    771e:	87 7f       	andi	r24, 0xF7	; 247
    7720:	80 93 e8 00 	sts	0x00E8, r24
				
				Endpoint_ClearStatusStage();
    7724:	c8 c1       	rjmp	.+912    	; 0x7ab6 <Endpoint_ClearStatusStage>
    7726:	08 95       	ret

00007728 <EVENT_USB_Device_ConfigurationChanged>:
 *  to relay data to and from the attached USB host.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	/* Setup CDC Notification, Rx and Tx Endpoints */
	Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT,
    7728:	83 e0       	ldi	r24, 0x03	; 3
    772a:	61 ec       	ldi	r22, 0xC1	; 193
    772c:	42 e0       	ldi	r20, 0x02	; 2
    772e:	99 d1       	rcall	.+818    	; 0x7a62 <Endpoint_ConfigureEndpoint_Prv>
		                       ENDPOINT_DIR_IN, CDC_NOTIFICATION_EPSIZE,
	                           ENDPOINT_BANK_SINGLE);

	Endpoint_ConfigureEndpoint(CDC_TX_EPNUM, EP_TYPE_BULK,
    7730:	81 e0       	ldi	r24, 0x01	; 1
    7732:	61 e8       	ldi	r22, 0x81	; 129
    7734:	42 e1       	ldi	r20, 0x12	; 18
    7736:	95 d1       	rcall	.+810    	; 0x7a62 <Endpoint_ConfigureEndpoint_Prv>
		                       ENDPOINT_DIR_IN, CDC_TXRX_EPSIZE,
	                           ENDPOINT_BANK_SINGLE);

	Endpoint_ConfigureEndpoint(CDC_RX_EPNUM, EP_TYPE_BULK,
    7738:	82 e0       	ldi	r24, 0x02	; 2
    773a:	60 e8       	ldi	r22, 0x80	; 128
    773c:	42 e1       	ldi	r20, 0x12	; 18
		                       ENDPOINT_DIR_OUT, CDC_TXRX_EPSIZE,
	                           ENDPOINT_BANK_SINGLE);
}
    773e:	91 c1       	rjmp	.+802    	; 0x7a62 <Endpoint_ConfigureEndpoint_Prv>

00007740 <ResetHardware>:
/** Resets all configured hardware required for the bootloader back to their original states. */
void ResetHardware(void)
{
	/* Shut down the USB subsystem */
	//USB_ResetInterface();
	USB_ShutDown();
    7740:	8b d2       	rcall	.+1302   	; 0x7c58 <USB_ShutDown>
	
	/* Relocate the interrupt vector table back to the application section */
	MCUCR = (1 << IVCE);
    7742:	81 e0       	ldi	r24, 0x01	; 1
    7744:	85 bf       	out	0x35, r24	; 53
	MCUCR = 0;
    7746:	15 be       	out	0x35, r1	; 53

	/* Re-enable RWW section */
	boot_rww_enable();
    7748:	81 e1       	ldi	r24, 0x11	; 17
    774a:	80 93 57 00 	sts	0x0057, r24
    774e:	e8 95       	spm
}
    7750:	08 95       	ret

00007752 <SetupHardware>:

/** Configures all hardware required for the bootloader. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    7752:	84 b7       	in	r24, 0x34	; 52
    7754:	87 7f       	andi	r24, 0xF7	; 247
    7756:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
    7758:	88 e1       	ldi	r24, 0x18	; 24
    775a:	0f b6       	in	r0, 0x3f	; 63
    775c:	f8 94       	cli
    775e:	80 93 60 00 	sts	0x0060, r24
    7762:	10 92 60 00 	sts	0x0060, r1
    7766:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
    7768:	80 e0       	ldi	r24, 0x00	; 0
    776a:	90 e0       	ldi	r25, 0x00	; 0
    776c:	20 e8       	ldi	r18, 0x80	; 128
    776e:	0f b6       	in	r0, 0x3f	; 63
    7770:	f8 94       	cli
    7772:	20 93 61 00 	sts	0x0061, r18
    7776:	80 93 61 00 	sts	0x0061, r24
    777a:	0f be       	out	0x3f, r0	; 63
	
	/* Relocate the interrupt vector table to the bootloader section */
	MCUCR = (1 << IVCE);
    777c:	81 e0       	ldi	r24, 0x01	; 1
    777e:	85 bf       	out	0x35, r24	; 53
	MCUCR = (1 << IVSEL);
    7780:	82 e0       	ldi	r24, 0x02	; 2
    7782:	85 bf       	out	0x35, r24	; 53
	
	/* Initialize USB Subsystem */
	USB_Init();
}
    7784:	7b c2       	rjmp	.+1270   	; 0x7c7c <USB_Init>

00007786 <main>:
 *  runs the bootloader processing routine until instructed to soft-exit, or hard-reset via the watchdog to start
 *  the loaded application code.
 */
int main(void)
{
	SetupHardware();
    7786:	e5 df       	rcall	.-54     	; 0x7752 <SetupHardware>
	
	LED_DDR |= LED_PIN;
    7788:	21 9a       	sbi	0x04, 1	; 4
	
	RUN_SW_DDR |= RUN_SW_PIN;
    778a:	6a 9a       	sbi	0x0d, 2	; 13
	RUN_SW_PORT |= RUN_SW_PIN;
    778c:	72 9a       	sbi	0x0e, 2	; 14
    778e:	80 ed       	ldi	r24, 0xD0	; 208
    7790:	97 e0       	ldi	r25, 0x07	; 7
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7792:	20 e9       	ldi	r18, 0x90	; 144
    7794:	31 e0       	ldi	r19, 0x01	; 1
    7796:	f9 01       	movw	r30, r18
    7798:	31 97       	sbiw	r30, 0x01	; 1
    779a:	f1 f7       	brne	.-4      	; 0x7798 <main+0x12>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    779c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    779e:	d9 f7       	brne	.-10     	; 0x7796 <main+0x10>
	
	_delay_ms(200);
	LED_PORT |= LED_PIN;
    77a0:	29 9a       	sbi	0x05, 1	; 5
    77a2:	80 ed       	ldi	r24, 0xD0	; 208
    77a4:	97 e0       	ldi	r25, 0x07	; 7
    77a6:	20 e9       	ldi	r18, 0x90	; 144
    77a8:	31 e0       	ldi	r19, 0x01	; 1
    77aa:	f9 01       	movw	r30, r18
    77ac:	31 97       	sbiw	r30, 0x01	; 1
    77ae:	f1 f7       	brne	.-4      	; 0x77ac <main+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    77b0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    77b2:	d9 f7       	brne	.-10     	; 0x77aa <main+0x24>
	_delay_ms(200);
	LED_PORT &= ~LED_PIN;
    77b4:	29 98       	cbi	0x05, 1	; 5
    77b6:	80 ed       	ldi	r24, 0xD0	; 208
    77b8:	97 e0       	ldi	r25, 0x07	; 7
    77ba:	20 e9       	ldi	r18, 0x90	; 144
    77bc:	31 e0       	ldi	r19, 0x01	; 1
    77be:	f9 01       	movw	r30, r18
    77c0:	31 97       	sbiw	r30, 0x01	; 1
    77c2:	f1 f7       	brne	.-4      	; 0x77c0 <main+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    77c4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    77c6:	d9 f7       	brne	.-10     	; 0x77be <main+0x38>
	_delay_ms(200);
	LED_PORT |= LED_PIN;
    77c8:	29 9a       	sbi	0x05, 1	; 5
    77ca:	80 ed       	ldi	r24, 0xD0	; 208
    77cc:	97 e0       	ldi	r25, 0x07	; 7
    77ce:	20 e9       	ldi	r18, 0x90	; 144
    77d0:	31 e0       	ldi	r19, 0x01	; 1
    77d2:	f9 01       	movw	r30, r18
    77d4:	31 97       	sbiw	r30, 0x01	; 1
    77d6:	f1 f7       	brne	.-4      	; 0x77d4 <main+0x4e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    77d8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    77da:	d9 f7       	brne	.-10     	; 0x77d2 <main+0x4c>
	_delay_ms(200);
	LED_PORT &= ~LED_PIN;
    77dc:	29 98       	cbi	0x05, 1	; 5
	
	/* Setup hardware required for the bootloader */
	
		
	LED_PORT |= LED_PIN;
    77de:	29 9a       	sbi	0x05, 1	; 5
    77e0:	08 c0       	rjmp	.+16     	; 0x77f2 <main+0x6c>
	

	while (RunBootloader)
	{		
		if (!(RUN_SW_PORTIN & RUN_SW_PIN)){
    77e2:	62 99       	sbic	0x0c, 2	; 12
    77e4:	04 c0       	rjmp	.+8      	; 0x77ee <main+0x68>
			RunBootloader = false;
    77e6:	10 92 0f 01 	sts	0x010F, r1
			
			ResetHardware();
    77ea:	aa df       	rcall	.-172    	; 0x7740 <ResetHardware>
			/* Start the user application */
			//AppPtr_t AppStartPtr = (AppPtr_t)0x0000;
			//AppStartPtr();	
			Bootloader_StartUserApp();
    77ec:	7b dc       	rcall	.-1802   	; 0x70e4 <Bootloader_StartUserApp>
		}
		
		CDC_Task();
    77ee:	b9 dc       	rcall	.-1678   	; 0x7162 <CDC_Task>
		USB_USBTask();
    77f0:	18 d3       	rcall	.+1584   	; 0x7e22 <USB_USBTask>
	
		
	LED_PORT |= LED_PIN;
	

	while (RunBootloader)
    77f2:	80 91 0f 01 	lds	r24, 0x010F
    77f6:	88 23       	and	r24, r24
    77f8:	a1 f7       	brne	.-24     	; 0x77e2 <main+0x5c>
		CDC_Task();
		USB_USBTask();
	}
	
	/* Reset all configured hardware to their default states for the user app */
	ResetHardware();
    77fa:	a2 df       	rcall	.-188    	; 0x7740 <ResetHardware>

	/* Start the user application */
	//AppPtr_t AppStartPtr = (AppPtr_t)0x0000;
	//AppStartPtr();
	Bootloader_StartUserApp();
    77fc:	73 dc       	rcall	.-1818   	; 0x70e4 <Bootloader_StartUserApp>
}
    77fe:	80 e0       	ldi	r24, 0x00	; 0
    7800:	90 e0       	ldi	r25, 0x00	; 0
    7802:	08 95       	ret

00007804 <CALLBACK_USB_GetDescriptor>:
 *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, this function
 *  is called so that the descriptor details can be passed back and the appropriate descriptor sent back to the
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue, const uint8_t wIndex, void** const DescriptorAddress)
{
    7804:	fa 01       	movw	r30, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	void*    Address = NULL;
	uint16_t Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    7806:	92 30       	cpi	r25, 0x02	; 2
    7808:	71 f0       	breq	.+28     	; 0x7826 <CALLBACK_USB_GetDescriptor+0x22>
    780a:	93 30       	cpi	r25, 0x03	; 3
    780c:	89 f0       	breq	.+34     	; 0x7830 <CALLBACK_USB_GetDescriptor+0x2c>
    780e:	91 30       	cpi	r25, 0x01	; 1
    7810:	29 f4       	brne	.+10     	; 0x781c <CALLBACK_USB_GetDescriptor+0x18>
    7812:	80 e1       	ldi	r24, 0x10	; 16
    7814:	91 e0       	ldi	r25, 0x01	; 1
    7816:	22 e1       	ldi	r18, 0x12	; 18
    7818:	30 e0       	ldi	r19, 0x00	; 0
    781a:	19 c0       	rjmp	.+50     	; 0x784e <CALLBACK_USB_GetDescriptor+0x4a>
    781c:	80 e0       	ldi	r24, 0x00	; 0
    781e:	90 e0       	ldi	r25, 0x00	; 0
    7820:	20 e0       	ldi	r18, 0x00	; 0
    7822:	30 e0       	ldi	r19, 0x00	; 0
    7824:	14 c0       	rjmp	.+40     	; 0x784e <CALLBACK_USB_GetDescriptor+0x4a>
    7826:	82 e2       	ldi	r24, 0x22	; 34
    7828:	91 e0       	ldi	r25, 0x01	; 1
    782a:	23 e4       	ldi	r18, 0x43	; 67
    782c:	30 e0       	ldi	r19, 0x00	; 0
    782e:	0f c0       	rjmp	.+30     	; 0x784e <CALLBACK_USB_GetDescriptor+0x4a>
		case DTYPE_Configuration:
			Address = (void*)&ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			if (!(DescriptorNumber))
    7830:	88 23       	and	r24, r24
    7832:	39 f4       	brne	.+14     	; 0x7842 <CALLBACK_USB_GetDescriptor+0x3e>
			{
				Address = (void*)&LanguageString;
				Size    = LanguageString.Header.Size;
    7834:	80 91 65 01 	lds	r24, 0x0165
    7838:	28 2f       	mov	r18, r24
    783a:	30 e0       	ldi	r19, 0x00	; 0
    783c:	85 e6       	ldi	r24, 0x65	; 101
    783e:	91 e0       	ldi	r25, 0x01	; 1
    7840:	06 c0       	rjmp	.+12     	; 0x784e <CALLBACK_USB_GetDescriptor+0x4a>
			}
			else
			{
				Address = (void*)&ProductString;
				Size    = ProductString.Header.Size;
    7842:	80 91 69 01 	lds	r24, 0x0169
    7846:	28 2f       	mov	r18, r24
    7848:	30 e0       	ldi	r19, 0x00	; 0
    784a:	89 e6       	ldi	r24, 0x69	; 105
    784c:	91 e0       	ldi	r25, 0x01	; 1
			}
			
			break;
	}
	
	*DescriptorAddress = Address;
    784e:	91 83       	std	Z+1, r25	; 0x01
    7850:	80 83       	st	Z, r24
	return Size;
}
    7852:	c9 01       	movw	r24, r18
    7854:	08 95       	ret

00007856 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    7856:	1f 93       	push	r17
    7858:	df 93       	push	r29
    785a:	cf 93       	push	r28
    785c:	00 d0       	rcall	.+0      	; 0x785e <USB_Device_ProcessControlRequest+0x8>
    785e:	cd b7       	in	r28, 0x3d	; 61
    7860:	de b7       	in	r29, 0x3e	; 62
    7862:	e8 e9       	ldi	r30, 0x98	; 152
    7864:	f1 e0       	ldi	r31, 0x01	; 1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
    7866:	80 91 f1 00 	lds	r24, 0x00F1
	bool     RequestHandled = false;
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;
	
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
    786a:	81 93       	st	Z+, r24
void USB_Device_ProcessControlRequest(void)
{
	bool     RequestHandled = false;
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;
	
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    786c:	81 e0       	ldi	r24, 0x01	; 1
    786e:	e0 3a       	cpi	r30, 0xA0	; 160
    7870:	f8 07       	cpc	r31, r24
    7872:	c9 f7       	brne	.-14     	; 0x7866 <USB_Device_ProcessControlRequest+0x10>
	  *(RequestHeader++) = Endpoint_Read_Byte();
	  
	uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    7874:	80 91 98 01 	lds	r24, 0x0198
	
	switch (USB_ControlRequest.bRequest)
    7878:	90 91 99 01 	lds	r25, 0x0199
    787c:	95 30       	cpi	r25, 0x05	; 5
    787e:	09 f4       	brne	.+2      	; 0x7882 <USB_Device_ProcessControlRequest+0x2c>
    7880:	6c c0       	rjmp	.+216    	; 0x795a <USB_Device_ProcessControlRequest+0x104>
    7882:	96 30       	cpi	r25, 0x06	; 6
    7884:	40 f4       	brcc	.+16     	; 0x7896 <USB_Device_ProcessControlRequest+0x40>
    7886:	91 30       	cpi	r25, 0x01	; 1
    7888:	79 f1       	breq	.+94     	; 0x78e8 <USB_Device_ProcessControlRequest+0x92>
    788a:	91 30       	cpi	r25, 0x01	; 1
    788c:	70 f0       	brcs	.+28     	; 0x78aa <USB_Device_ProcessControlRequest+0x54>
    788e:	93 30       	cpi	r25, 0x03	; 3
    7890:	09 f0       	breq	.+2      	; 0x7894 <USB_Device_ProcessControlRequest+0x3e>
    7892:	d2 c0       	rjmp	.+420    	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
    7894:	29 c0       	rjmp	.+82     	; 0x78e8 <USB_Device_ProcessControlRequest+0x92>
    7896:	98 30       	cpi	r25, 0x08	; 8
    7898:	09 f4       	brne	.+2      	; 0x789c <USB_Device_ProcessControlRequest+0x46>
    789a:	a0 c0       	rjmp	.+320    	; 0x79dc <USB_Device_ProcessControlRequest+0x186>
    789c:	99 30       	cpi	r25, 0x09	; 9
    789e:	09 f4       	brne	.+2      	; 0x78a2 <USB_Device_ProcessControlRequest+0x4c>
    78a0:	b3 c0       	rjmp	.+358    	; 0x7a08 <USB_Device_ProcessControlRequest+0x1b2>
    78a2:	96 30       	cpi	r25, 0x06	; 6
    78a4:	09 f0       	breq	.+2      	; 0x78a8 <USB_Device_ProcessControlRequest+0x52>
    78a6:	c8 c0       	rjmp	.+400    	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
    78a8:	75 c0       	rjmp	.+234    	; 0x7994 <USB_Device_ProcessControlRequest+0x13e>
	{
		case REQ_GetStatus:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    78aa:	80 38       	cpi	r24, 0x80	; 128
    78ac:	09 f4       	brne	.+2      	; 0x78b0 <USB_Device_ProcessControlRequest+0x5a>
    78ae:	c5 c0       	rjmp	.+394    	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
    78b0:	82 38       	cpi	r24, 0x82	; 130
    78b2:	09 f0       	breq	.+2      	; 0x78b6 <USB_Device_ProcessControlRequest+0x60>
    78b4:	c1 c0       	rjmp	.+386    	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
	#endif
			break;
#endif
#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint(USB_ControlRequest.wIndex & 0xFF);
    78b6:	80 91 9c 01 	lds	r24, 0x019C
    78ba:	80 93 e9 00 	sts	0x00E9, r24

			CurrentStatus = Endpoint_IsStalled();
    78be:	80 91 eb 00 	lds	r24, 0x00EB

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);			  
    78c2:	10 92 e9 00 	sts	0x00E9, r1
#endif
		default:
			return;
	}

	Endpoint_ClearSETUP();
    78c6:	20 91 e8 00 	lds	r18, 0x00E8
    78ca:	27 7f       	andi	r18, 0xF7	; 247
    78cc:	20 93 e8 00 	sts	0x00E8, r18
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    78d0:	90 e0       	ldi	r25, 0x00	; 0
    78d2:	25 e0       	ldi	r18, 0x05	; 5
    78d4:	96 95       	lsr	r25
    78d6:	87 95       	ror	r24
    78d8:	2a 95       	dec	r18
    78da:	e1 f7       	brne	.-8      	; 0x78d4 <USB_Device_ProcessControlRequest+0x7e>
    78dc:	81 70       	andi	r24, 0x01	; 1
    78de:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Word >> 8);
    78e2:	10 92 f1 00 	sts	0x00F1, r1
    78e6:	85 c0       	rjmp	.+266    	; 0x79f2 <USB_Device_ProcessControlRequest+0x19c>
			}

			break;
		case REQ_ClearFeature:
		case REQ_SetFeature:
			if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    78e8:	88 23       	and	r24, r24
    78ea:	19 f0       	breq	.+6      	; 0x78f2 <USB_Device_ProcessControlRequest+0x9c>
    78ec:	82 30       	cpi	r24, 0x02	; 2
    78ee:	09 f0       	breq	.+2      	; 0x78f2 <USB_Device_ProcessControlRequest+0x9c>
    78f0:	a3 c0       	rjmp	.+326    	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{	
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    78f2:	8f 71       	andi	r24, 0x1F	; 31
    78f4:	82 30       	cpi	r24, 0x02	; 2
    78f6:	09 f0       	breq	.+2      	; 0x78fa <USB_Device_ProcessControlRequest+0xa4>
    78f8:	a0 c0       	rjmp	.+320    	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
			
			break;			
#endif
#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_ENDPOINT_HALT)
    78fa:	80 91 9a 01 	lds	r24, 0x019A
    78fe:	88 23       	and	r24, r24
    7900:	31 f5       	brne	.+76     	; 0x794e <USB_Device_ProcessControlRequest+0xf8>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    7902:	20 91 9c 01 	lds	r18, 0x019C
    7906:	27 70       	andi	r18, 0x07	; 7
				
				if (EndpointIndex == ENDPOINT_CONTROLEP)
    7908:	09 f4       	brne	.+2      	; 0x790c <USB_Device_ProcessControlRequest+0xb6>
    790a:	97 c0       	rjmp	.+302    	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);
    790c:	20 93 e9 00 	sts	0x00E9, r18

				if (Endpoint_IsEnabled())
    7910:	80 91 eb 00 	lds	r24, 0x00EB
    7914:	80 ff       	sbrs	r24, 0
    7916:	1b c0       	rjmp	.+54     	; 0x794e <USB_Device_ProcessControlRequest+0xf8>
				{				
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    7918:	93 30       	cpi	r25, 0x03	; 3
    791a:	21 f4       	brne	.+8      	; 0x7924 <USB_Device_ProcessControlRequest+0xce>
					{
						Endpoint_StallTransaction();
    791c:	80 91 eb 00 	lds	r24, 0x00EB
    7920:	80 62       	ori	r24, 0x20	; 32
    7922:	13 c0       	rjmp	.+38     	; 0x794a <USB_Device_ProcessControlRequest+0xf4>
					}
					else
					{
						Endpoint_ClearStall();
    7924:	80 91 eb 00 	lds	r24, 0x00EB
    7928:	80 61       	ori	r24, 0x10	; 16
    792a:	80 93 eb 00 	sts	0x00EB, r24
						Endpoint_ResetFIFO(EndpointIndex);
    792e:	81 e0       	ldi	r24, 0x01	; 1
    7930:	90 e0       	ldi	r25, 0x00	; 0
    7932:	02 c0       	rjmp	.+4      	; 0x7938 <USB_Device_ProcessControlRequest+0xe2>
    7934:	88 0f       	add	r24, r24
    7936:	99 1f       	adc	r25, r25
    7938:	2a 95       	dec	r18
    793a:	e2 f7       	brpl	.-8      	; 0x7934 <USB_Device_ProcessControlRequest+0xde>
    793c:	80 93 ea 00 	sts	0x00EA, r24
    7940:	10 92 ea 00 	sts	0x00EA, r1
						Endpoint_ResetDataToggle();
    7944:	80 91 eb 00 	lds	r24, 0x00EB
    7948:	88 60       	ori	r24, 0x08	; 8
    794a:	80 93 eb 00 	sts	0x00EB, r24
#endif
		default:
			return;
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    794e:	10 92 e9 00 	sts	0x00E9, r1

	Endpoint_ClearSETUP();
    7952:	80 91 e8 00 	lds	r24, 0x00E8
    7956:	87 7f       	andi	r24, 0xF7	; 247
    7958:	53 c0       	rjmp	.+166    	; 0x7a00 <USB_Device_ProcessControlRequest+0x1aa>
				RequestHandled = true;
			}

			break;
		case REQ_SetAddress:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    795a:	88 23       	and	r24, r24
    795c:	09 f0       	breq	.+2      	; 0x7960 <USB_Device_ProcessControlRequest+0x10a>
    795e:	6c c0       	rjmp	.+216    	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    7960:	10 91 9a 01 	lds	r17, 0x019A

	Endpoint_ClearSETUP();
    7964:	80 91 e8 00 	lds	r24, 0x00E8
    7968:	87 7f       	andi	r24, 0xF7	; 247
    796a:	80 93 e8 00 	sts	0x00E8, r24
	
	Endpoint_ClearStatusStage();
    796e:	a3 d0       	rcall	.+326    	; 0x7ab6 <Endpoint_ClearStatusStage>
    7970:	04 c0       	rjmp	.+8      	; 0x797a <USB_Device_ProcessControlRequest+0x124>
	
	while (!(Endpoint_IsINReady()))
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    7972:	8e b3       	in	r24, 0x1e	; 30
    7974:	88 23       	and	r24, r24
    7976:	09 f4       	brne	.+2      	; 0x797a <USB_Device_ProcessControlRequest+0x124>
    7978:	60 c0       	rjmp	.+192    	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>

	Endpoint_ClearSETUP();
	
	Endpoint_ClearStatusStage();
	
	while (!(Endpoint_IsINReady()))
    797a:	80 91 e8 00 	lds	r24, 0x00E8
    797e:	80 ff       	sbrs	r24, 0
    7980:	f8 cf       	rjmp	.-16     	; 0x7972 <USB_Device_ProcessControlRequest+0x11c>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    7982:	91 2f       	mov	r25, r17
    7984:	9f 77       	andi	r25, 0x7F	; 127
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return;
	}

	if (DeviceAddress)
    7986:	11 f0       	breq	.+4      	; 0x798c <USB_Device_ProcessControlRequest+0x136>
	  USB_DeviceState = DEVICE_STATE_Addressed;
    7988:	83 e0       	ldi	r24, 0x03	; 3
    798a:	8e bb       	out	0x1e, r24	; 30

	UDADDR = ((1 << ADDEN) | DeviceAddress);
    798c:	90 68       	ori	r25, 0x80	; 128
    798e:	90 93 e3 00 	sts	0x00E3, r25
    7992:	53 c0       	rjmp	.+166    	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
				RequestHandled = true;
			}

			break;
		case REQ_GetDescriptor:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7994:	80 58       	subi	r24, 0x80	; 128
    7996:	82 30       	cpi	r24, 0x02	; 2
    7998:	08 f0       	brcs	.+2      	; 0x799c <USB_Device_ProcessControlRequest+0x146>
    799a:	4e c0       	rjmp	.+156    	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif
	
	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    799c:	80 91 9a 01 	lds	r24, 0x019A
    79a0:	90 91 9b 01 	lds	r25, 0x019B
    79a4:	60 91 9c 01 	lds	r22, 0x019C
    79a8:	ae 01       	movw	r20, r28
    79aa:	4f 5f       	subi	r20, 0xFF	; 255
    79ac:	5f 4f       	sbci	r21, 0xFF	; 255
    79ae:	2a df       	rcall	.-428    	; 0x7804 <CALLBACK_USB_GetDescriptor>
    79b0:	bc 01       	movw	r22, r24
    79b2:	00 97       	sbiw	r24, 0x00	; 0
    79b4:	09 f4       	brne	.+2      	; 0x79b8 <USB_Device_ProcessControlRequest+0x162>
    79b6:	41 c0       	rjmp	.+130    	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
													 )) == NO_DESCRIPTOR)
	{
		return;
	}
	
	Endpoint_ClearSETUP();
    79b8:	80 91 e8 00 	lds	r24, 0x00E8
    79bc:	87 7f       	andi	r24, 0xF7	; 247
    79be:	80 93 e8 00 	sts	0x00E8, r24

	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
    79c2:	89 81       	ldd	r24, Y+1	; 0x01
    79c4:	9a 81       	ldd	r25, Y+2	; 0x02
    79c6:	9e d0       	rcall	.+316    	; 0x7b04 <Endpoint_Write_Control_Stream_LE>
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);	
	#endif

	Endpoint_ClearOUT();
    79c8:	80 91 e8 00 	lds	r24, 0x00E8
    79cc:	98 2f       	mov	r25, r24
    79ce:	9b 7f       	andi	r25, 0xFB	; 251
    79d0:	90 93 e8 00 	sts	0x00E8, r25
    79d4:	8f 77       	andi	r24, 0x7F	; 127
    79d6:	80 93 e8 00 	sts	0x00E8, r24
    79da:	2f c0       	rjmp	.+94     	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
				RequestHandled = true;
			}
			
			break;
		case REQ_GetConfiguration:
			if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    79dc:	80 38       	cpi	r24, 0x80	; 128
    79de:	61 f5       	brne	.+88     	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
	EVENT_USB_Device_ConfigurationChanged();
}

void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();
    79e0:	80 91 e8 00 	lds	r24, 0x00E8
    79e4:	87 7f       	andi	r24, 0xF7	; 247
    79e6:	80 93 e8 00 	sts	0x00E8, r24

	Endpoint_Write_Byte(USB_ConfigurationNumber);
    79ea:	80 91 96 01 	lds	r24, 0x0196
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    79ee:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_ClearIN();
    79f2:	80 91 e8 00 	lds	r24, 0x00E8
    79f6:	98 2f       	mov	r25, r24
    79f8:	9e 7f       	andi	r25, 0xFE	; 254
    79fa:	90 93 e8 00 	sts	0x00E8, r25
    79fe:	8f 77       	andi	r24, 0x7F	; 127
    7a00:	80 93 e8 00 	sts	0x00E8, r24

	Endpoint_ClearStatusStage();
    7a04:	58 d0       	rcall	.+176    	; 0x7ab6 <Endpoint_ClearStatusStage>
    7a06:	19 c0       	rjmp	.+50     	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
				RequestHandled = true;
			}

			break;
		case REQ_SetConfiguration:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7a08:	88 23       	and	r24, r24
    7a0a:	b1 f4       	brne	.+44     	; 0x7a38 <USB_Device_ProcessControlRequest+0x1e2>
}

static void USB_Device_SetConfiguration(void)
{
#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    7a0c:	90 91 9a 01 	lds	r25, 0x019A
    7a10:	92 30       	cpi	r25, 0x02	; 2
    7a12:	98 f4       	brcc	.+38     	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>
		  return;
	}
	#endif
#endif
	
	Endpoint_ClearSETUP();
    7a14:	80 91 e8 00 	lds	r24, 0x00E8
    7a18:	87 7f       	andi	r24, 0xF7	; 247
    7a1a:	80 93 e8 00 	sts	0x00E8, r24

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    7a1e:	90 93 96 01 	sts	0x0196, r25

	Endpoint_ClearStatusStage();
    7a22:	49 d0       	rcall	.+146    	; 0x7ab6 <Endpoint_ClearStatusStage>

	USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
    7a24:	80 91 96 01 	lds	r24, 0x0196
    7a28:	88 23       	and	r24, r24
    7a2a:	11 f4       	brne	.+4      	; 0x7a30 <USB_Device_ProcessControlRequest+0x1da>
    7a2c:	83 e0       	ldi	r24, 0x03	; 3
    7a2e:	01 c0       	rjmp	.+2      	; 0x7a32 <USB_Device_ProcessControlRequest+0x1dc>
    7a30:	84 e0       	ldi	r24, 0x04	; 4
    7a32:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
    7a34:	79 de       	rcall	.-782    	; 0x7728 <EVENT_USB_Device_ConfigurationChanged>
    7a36:	01 c0       	rjmp	.+2      	; 0x7a3a <USB_Device_ProcessControlRequest+0x1e4>

			break;
	}

	if (!(RequestHandled))
	  EVENT_USB_Device_UnhandledControlRequest();
    7a38:	25 de       	rcall	.-950    	; 0x7684 <EVENT_USB_Device_UnhandledControlRequest>
	  
	if (Endpoint_IsSETUPReceived())
    7a3a:	80 91 e8 00 	lds	r24, 0x00E8
    7a3e:	83 ff       	sbrs	r24, 3
    7a40:	0a c0       	rjmp	.+20     	; 0x7a56 <USB_Device_ProcessControlRequest+0x200>
	{
		Endpoint_StallTransaction();
    7a42:	80 91 eb 00 	lds	r24, 0x00EB
    7a46:	80 62       	ori	r24, 0x20	; 32
    7a48:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ClearSETUP();		
    7a4c:	80 91 e8 00 	lds	r24, 0x00E8
    7a50:	87 7f       	andi	r24, 0xF7	; 247
    7a52:	80 93 e8 00 	sts	0x00E8, r24
	}
}
    7a56:	0f 90       	pop	r0
    7a58:	0f 90       	pop	r0
    7a5a:	cf 91       	pop	r28
    7a5c:	df 91       	pop	r29
    7a5e:	1f 91       	pop	r17
    7a60:	08 95       	ret

00007a62 <Endpoint_ConfigureEndpoint_Prv>:

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number, const uint8_t UECFG0XData, const uint8_t UECFG1XData)
{
	Endpoint_SelectEndpoint(Number);
    7a62:	80 93 e9 00 	sts	0x00E9, r24
	Endpoint_EnableEndpoint();
    7a66:	80 91 eb 00 	lds	r24, 0x00EB
    7a6a:	81 60       	ori	r24, 0x01	; 1
    7a6c:	80 93 eb 00 	sts	0x00EB, r24

	UECFG1X = 0;
    7a70:	10 92 ed 00 	sts	0x00ED, r1

	UECFG0X = UECFG0XData;
    7a74:	60 93 ec 00 	sts	0x00EC, r22
	UECFG1X = UECFG1XData;
    7a78:	40 93 ed 00 	sts	0x00ED, r20

	return Endpoint_IsConfigured();
    7a7c:	80 91 ee 00 	lds	r24, 0x00EE
}
    7a80:	88 1f       	adc	r24, r24
    7a82:	88 27       	eor	r24, r24
    7a84:	88 1f       	adc	r24, r24
    7a86:	08 95       	ret

00007a88 <Endpoint_ClearEndpoints>:

void Endpoint_ClearEndpoints(void)
{
	UEINT = 0;
    7a88:	10 92 f4 00 	sts	0x00F4, r1
    7a8c:	90 e0       	ldi	r25, 0x00	; 0

	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		Endpoint_SelectEndpoint(EPNum);	
    7a8e:	90 93 e9 00 	sts	0x00E9, r25
		UEIENX = 0;
    7a92:	10 92 f0 00 	sts	0x00F0, r1
		UEINTX = 0;
    7a96:	10 92 e8 00 	sts	0x00E8, r1
		Endpoint_DeallocateMemory();
    7a9a:	80 91 ed 00 	lds	r24, 0x00ED
    7a9e:	8d 7f       	andi	r24, 0xFD	; 253
    7aa0:	80 93 ed 00 	sts	0x00ED, r24
		Endpoint_DisableEndpoint();
    7aa4:	80 91 eb 00 	lds	r24, 0x00EB
    7aa8:	8e 7f       	andi	r24, 0xFE	; 254
    7aaa:	80 93 eb 00 	sts	0x00EB, r24

void Endpoint_ClearEndpoints(void)
{
	UEINT = 0;

	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    7aae:	9f 5f       	subi	r25, 0xFF	; 255
    7ab0:	97 30       	cpi	r25, 0x07	; 7
    7ab2:	69 f7       	brne	.-38     	; 0x7a8e <Endpoint_ClearEndpoints+0x6>
		UEIENX = 0;
		UEINTX = 0;
		Endpoint_DeallocateMemory();
		Endpoint_DisableEndpoint();
	}
}
    7ab4:	08 95       	ret

00007ab6 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    7ab6:	80 91 98 01 	lds	r24, 0x0198
    7aba:	88 23       	and	r24, r24
    7abc:	ac f4       	brge	.+42     	; 0x7ae8 <Endpoint_ClearStatusStage+0x32>
    7abe:	03 c0       	rjmp	.+6      	; 0x7ac6 <Endpoint_ClearStatusStage+0x10>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    7ac0:	8e b3       	in	r24, 0x1e	; 30
    7ac2:	88 23       	and	r24, r24
    7ac4:	f1 f0       	breq	.+60     	; 0x7b02 <Endpoint_ClearStatusStage+0x4c>

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    7ac6:	80 91 e8 00 	lds	r24, 0x00E8
    7aca:	82 ff       	sbrs	r24, 2
    7acc:	f9 cf       	rjmp	.-14     	; 0x7ac0 <Endpoint_ClearStatusStage+0xa>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}

		Endpoint_ClearOUT();
    7ace:	80 91 e8 00 	lds	r24, 0x00E8
    7ad2:	98 2f       	mov	r25, r24
    7ad4:	9b 7f       	andi	r25, 0xFB	; 251
    7ad6:	90 93 e8 00 	sts	0x00E8, r25
    7ada:	8f 77       	andi	r24, 0x7F	; 127
    7adc:	80 93 e8 00 	sts	0x00E8, r24
    7ae0:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    7ae2:	8e b3       	in	r24, 0x1e	; 30
    7ae4:	88 23       	and	r24, r24
    7ae6:	69 f0       	breq	.+26     	; 0x7b02 <Endpoint_ClearStatusStage+0x4c>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    7ae8:	80 91 e8 00 	lds	r24, 0x00E8
    7aec:	80 ff       	sbrs	r24, 0
    7aee:	f9 cf       	rjmp	.-14     	; 0x7ae2 <Endpoint_ClearStatusStage+0x2c>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
			  return;
		}
		
		Endpoint_ClearIN();
    7af0:	80 91 e8 00 	lds	r24, 0x00E8
    7af4:	98 2f       	mov	r25, r24
    7af6:	9e 7f       	andi	r25, 0xFE	; 254
    7af8:	90 93 e8 00 	sts	0x00E8, r25
    7afc:	8f 77       	andi	r24, 0x7F	; 127
    7afe:	80 93 e8 00 	sts	0x00E8, r24
    7b02:	08 95       	ret

00007b04 <Endpoint_Write_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer, uint16_t Length)
{
    7b04:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;
	
	if (Length > USB_ControlRequest.wLength)
    7b06:	40 91 9e 01 	lds	r20, 0x019E
    7b0a:	50 91 9f 01 	lds	r21, 0x019F
    7b0e:	46 17       	cp	r20, r22
    7b10:	57 07       	cpc	r21, r23
    7b12:	18 f4       	brcc	.+6      	; 0x7b1a <Endpoint_Write_Control_Stream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer, uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    7b14:	d9 01       	movw	r26, r18
    7b16:	e0 e0       	ldi	r30, 0x00	; 0
    7b18:	48 c0       	rjmp	.+144    	; 0x7baa <Endpoint_Write_Control_Stream_LE+0xa6>
	bool     LastPacketFull = false;
	
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    7b1a:	61 15       	cp	r22, r1
    7b1c:	71 05       	cpc	r23, r1
    7b1e:	11 f0       	breq	.+4      	; 0x7b24 <Endpoint_Write_Control_Stream_LE+0x20>
    7b20:	ab 01       	movw	r20, r22
    7b22:	f8 cf       	rjmp	.-16     	; 0x7b14 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();
    7b24:	80 91 e8 00 	lds	r24, 0x00E8
    7b28:	98 2f       	mov	r25, r24
    7b2a:	9e 7f       	andi	r25, 0xFE	; 254
    7b2c:	90 93 e8 00 	sts	0x00E8, r25
    7b30:	8f 77       	andi	r24, 0x7F	; 127
    7b32:	80 93 e8 00 	sts	0x00E8, r24
    7b36:	40 e0       	ldi	r20, 0x00	; 0
    7b38:	50 e0       	ldi	r21, 0x00	; 0
    7b3a:	ec cf       	rjmp	.-40     	; 0x7b14 <Endpoint_Write_Control_Stream_LE+0x10>

	while (Length || LastPacketFull)
	{
		if (Endpoint_IsSETUPReceived())
    7b3c:	80 91 e8 00 	lds	r24, 0x00E8
    7b40:	83 ff       	sbrs	r24, 3
    7b42:	02 c0       	rjmp	.+4      	; 0x7b48 <Endpoint_Write_Control_Stream_LE+0x44>
    7b44:	81 e0       	ldi	r24, 0x01	; 1
    7b46:	08 95       	ret
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    7b48:	80 91 e8 00 	lds	r24, 0x00E8
    7b4c:	82 fd       	sbrc	r24, 2
    7b4e:	36 c0       	rjmp	.+108    	; 0x7bbc <Endpoint_Write_Control_Stream_LE+0xb8>
		  break;
		
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    7b50:	8e b3       	in	r24, 0x1e	; 30
    7b52:	88 23       	and	r24, r24
    7b54:	c9 f1       	breq	.+114    	; 0x7bc8 <Endpoint_Write_Control_Stream_LE+0xc4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		  
		if (Endpoint_IsINReady())
    7b56:	80 91 e8 00 	lds	r24, 0x00E8
    7b5a:	80 ff       	sbrs	r24, 0
    7b5c:	26 c0       	rjmp	.+76     	; 0x7baa <Endpoint_Write_Control_Stream_LE+0xa6>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();
    7b5e:	80 91 f3 00 	lds	r24, 0x00F3
    7b62:	90 91 f2 00 	lds	r25, 0x00F2
    7b66:	78 2f       	mov	r23, r24
    7b68:	60 e0       	ldi	r22, 0x00	; 0
    7b6a:	29 2f       	mov	r18, r25
    7b6c:	30 e0       	ldi	r19, 0x00	; 0
    7b6e:	26 2b       	or	r18, r22
    7b70:	37 2b       	or	r19, r23
    7b72:	07 c0       	rjmp	.+14     	; 0x7b82 <Endpoint_Write_Control_Stream_LE+0x7e>
		
			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    7b74:	8d 91       	ld	r24, X+
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    7b76:	80 93 f1 00 	sts	0x00F1, r24
				Length--;
    7b7a:	41 50       	subi	r20, 0x01	; 1
    7b7c:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    7b7e:	2f 5f       	subi	r18, 0xFF	; 255
    7b80:	3f 4f       	sbci	r19, 0xFF	; 255
		  
		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();
		
			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    7b82:	41 15       	cp	r20, r1
    7b84:	51 05       	cpc	r21, r1
    7b86:	19 f0       	breq	.+6      	; 0x7b8e <Endpoint_Write_Control_Stream_LE+0x8a>
    7b88:	28 30       	cpi	r18, 0x08	; 8
    7b8a:	31 05       	cpc	r19, r1
    7b8c:	98 f3       	brcs	.-26     	; 0x7b74 <Endpoint_Write_Control_Stream_LE+0x70>
				TEMPLATE_TRANSFER_BYTE(DataStream);
				Length--;
				BytesInEndpoint++;
			}
			
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    7b8e:	e0 e0       	ldi	r30, 0x00	; 0
    7b90:	28 30       	cpi	r18, 0x08	; 8
    7b92:	31 05       	cpc	r19, r1
    7b94:	09 f4       	brne	.+2      	; 0x7b98 <Endpoint_Write_Control_Stream_LE+0x94>
    7b96:	e1 e0       	ldi	r30, 0x01	; 1
			Endpoint_ClearIN();
    7b98:	80 91 e8 00 	lds	r24, 0x00E8
    7b9c:	98 2f       	mov	r25, r24
    7b9e:	9e 7f       	andi	r25, 0xFE	; 254
    7ba0:	90 93 e8 00 	sts	0x00E8, r25
    7ba4:	8f 77       	andi	r24, 0x7F	; 127
    7ba6:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    7baa:	41 15       	cp	r20, r1
    7bac:	51 05       	cpc	r21, r1
    7bae:	31 f6       	brne	.-116    	; 0x7b3c <Endpoint_Write_Control_Stream_LE+0x38>
    7bb0:	ee 23       	and	r30, r30
    7bb2:	21 f6       	brne	.-120    	; 0x7b3c <Endpoint_Write_Control_Stream_LE+0x38>
    7bb4:	03 c0       	rjmp	.+6      	; 0x7bbc <Endpoint_Write_Control_Stream_LE+0xb8>
		}
	}
	
	while (!(Endpoint_IsOUTReceived()))
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    7bb6:	8e b3       	in	r24, 0x1e	; 30
    7bb8:	88 23       	and	r24, r24
    7bba:	31 f0       	breq	.+12     	; 0x7bc8 <Endpoint_Write_Control_Stream_LE+0xc4>
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}
	
	while (!(Endpoint_IsOUTReceived()))
    7bbc:	80 91 e8 00 	lds	r24, 0x00E8
    7bc0:	82 ff       	sbrs	r24, 2
    7bc2:	f9 cf       	rjmp	.-14     	; 0x7bb6 <Endpoint_Write_Control_Stream_LE+0xb2>
    7bc4:	80 e0       	ldi	r24, 0x00	; 0
    7bc6:	08 95       	ret
    7bc8:	82 e0       	ldi	r24, 0x02	; 2
		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;	
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    7bca:	08 95       	ret

00007bcc <USB_ResetInterface>:
	#endif
}

void USB_ResetInterface(void)
{
	USB_INT_DisableAllInterrupts();
    7bcc:	63 d0       	rcall	.+198    	; 0x7c94 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    7bce:	6a d0       	rcall	.+212    	; 0x7ca4 <USB_INT_ClearAllInterrupts>
	#if defined(USB_CAN_BE_HOST)
	USB_HostState   = HOST_STATE_Unattached;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	USB_DeviceState = DEVICE_STATE_Unattached;
    7bd0:	1e ba       	out	0x1e, r1	; 30
	USB_ConfigurationNumber  = 0;
    7bd2:	10 92 96 01 	sts	0x0196, r1
	#endif
	
	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
    7bd6:	8a e4       	ldi	r24, 0x4A	; 74
    7bd8:	82 bf       	out	0x32, r24	; 50
		#endif

		USB_PLL_On();
    7bda:	80 e1       	ldi	r24, 0x10	; 16
    7bdc:	89 bd       	out	0x29, r24	; 41
    7bde:	89 b5       	in	r24, 0x29	; 41
    7be0:	82 60       	ori	r24, 0x02	; 2
    7be2:	89 bd       	out	0x29, r24	; 41
		while (!(USB_PLL_IsReady()));
    7be4:	09 b4       	in	r0, 0x29	; 41
    7be6:	00 fe       	sbrs	r0, 0
    7be8:	fd cf       	rjmp	.-6      	; 0x7be4 <USB_ResetInterface+0x18>
	}
	
	USB_Controller_Reset();
    7bea:	80 91 d8 00 	lds	r24, 0x00D8
    7bee:	98 2f       	mov	r25, r24
    7bf0:	9f 77       	andi	r25, 0x7F	; 127
    7bf2:	90 93 d8 00 	sts	0x00D8, r25
    7bf6:	80 68       	ori	r24, 0x80	; 128
    7bf8:	80 93 d8 00 	sts	0x00D8, r24
		USB_CurrentMode = USB_GetUSBModeFromUID();
	}
	#endif
		
	if (!(USB_Options & USB_OPT_REG_DISABLED))
	  USB_REG_On();
    7bfc:	80 91 d7 00 	lds	r24, 0x00D7
    7c00:	81 60       	ori	r24, 0x01	; 1
    7c02:	80 93 d7 00 	sts	0x00D7, r24
	else
	  USB_REG_Off();
	
	USB_CLK_Unfreeze();
    7c06:	80 91 d8 00 	lds	r24, 0x00D8
    7c0a:	8f 7d       	andi	r24, 0xDF	; 223
    7c0c:	80 93 d8 00 	sts	0x00D8, r24
	if (USB_CurrentMode == USB_MODE_DEVICE)
	{
		if (USB_Options & USB_DEVICE_OPT_LOWSPEED)
		  USB_Device_SetLowSpeed();
		else
		  USB_Device_SetFullSpeed();
    7c10:	80 91 e0 00 	lds	r24, 0x00E0
    7c14:	8b 7f       	andi	r24, 0xFB	; 251
    7c16:	80 93 e0 00 	sts	0x00E0, r24
			#endif
		}
	}
	#endif

	USB_Attach();
    7c1a:	80 91 e0 00 	lds	r24, 0x00E0
    7c1e:	8e 7f       	andi	r24, 0xFE	; 254
    7c20:	80 93 e0 00 	sts	0x00E0, r24
	
	#if defined(USB_DEVICE_ONLY)
	USB_INT_Clear(USB_INT_SUSPEND);
    7c24:	80 91 e1 00 	lds	r24, 0x00E1
    7c28:	8e 7f       	andi	r24, 0xFE	; 254
    7c2a:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_SUSPEND);
    7c2e:	80 91 e2 00 	lds	r24, 0x00E2
    7c32:	81 60       	ori	r24, 0x01	; 1
    7c34:	80 93 e2 00 	sts	0x00E2, r24
	USB_INT_Clear(USB_INT_EORSTI);
    7c38:	80 91 e1 00 	lds	r24, 0x00E1
    7c3c:	87 7f       	andi	r24, 0xF7	; 247
    7c3e:	80 93 e1 00 	sts	0x00E1, r24
	USB_INT_Enable(USB_INT_EORSTI);
    7c42:	80 91 e2 00 	lds	r24, 0x00E2
    7c46:	88 60       	ori	r24, 0x08	; 8
    7c48:	80 93 e2 00 	sts	0x00E2, r24

		#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
		USB_INT_Enable(USB_INT_VBUS);
    7c4c:	80 91 d8 00 	lds	r24, 0x00D8
    7c50:	81 60       	ori	r24, 0x01	; 1
    7c52:	80 93 d8 00 	sts	0x00D8, r24
		
		USB_INT_Enable(USB_INT_SRPI);
		USB_INT_Enable(USB_INT_BCERRI);
	}
	#endif
}
    7c56:	08 95       	ret

00007c58 <USB_ShutDown>:
	sei();
}

void USB_ShutDown(void)
{
	USB_ResetInterface();
    7c58:	b9 df       	rcall	.-142    	; 0x7bcc <USB_ResetInterface>
	USB_Detach();
    7c5a:	e0 ee       	ldi	r30, 0xE0	; 224
    7c5c:	f0 e0       	ldi	r31, 0x00	; 0
    7c5e:	80 81       	ld	r24, Z
    7c60:	81 60       	ori	r24, 0x01	; 1
    7c62:	80 83       	st	Z, r24
	USB_Controller_Disable();
    7c64:	e8 ed       	ldi	r30, 0xD8	; 216
    7c66:	f0 e0       	ldi	r31, 0x00	; 0
    7c68:	80 81       	ld	r24, Z
    7c6a:	8f 77       	andi	r24, 0x7F	; 127
    7c6c:	80 83       	st	Z, r24
	
	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	  USB_PLL_Off();
    7c6e:	19 bc       	out	0x29, r1	; 41
	
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
    7c70:	80 81       	ld	r24, Z
    7c72:	8f 7e       	andi	r24, 0xEF	; 239
    7c74:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	UHWCON &= ~(1 << UIDE);
	#endif

	USB_IsInitialized = false;
    7c76:	10 92 97 01 	sts	0x0197, r1

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_NONE;
	#endif
}
    7c7a:	08 95       	ret

00007c7c <USB_Init>:
		EVENT_USB_InitFailure(USB_INITERROR_NoUSBModeSpecified);
		return;
	}
	#endif
	
	USB_ResetInterface();
    7c7c:	a7 df       	rcall	.-178    	; 0x7bcc <USB_ResetInterface>

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_On();
    7c7e:	e8 ed       	ldi	r30, 0xD8	; 216
    7c80:	f0 e0       	ldi	r31, 0x00	; 0
    7c82:	80 81       	ld	r24, Z
    7c84:	80 61       	ori	r24, 0x10	; 16
    7c86:	80 83       	st	Z, r24
	#endif

	USB_IsInitialized = true;
    7c88:	81 e0       	ldi	r24, 0x01	; 1
    7c8a:	80 93 97 01 	sts	0x0197, r24

	sei();
    7c8e:	78 94       	sei
}
    7c90:	08 95       	ret

00007c92 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    7c92:	08 95       	ret

00007c94 <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));				
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);					
    7c94:	e8 ed       	ldi	r30, 0xD8	; 216
    7c96:	f0 e0       	ldi	r31, 0x00	; 0
    7c98:	80 81       	ld	r24, Z
    7c9a:	8e 7f       	andi	r24, 0xFE	; 254
    7c9c:	80 83       	st	Z, r24
	UHIEN   = 0;
	OTGIEN  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    7c9e:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    7ca2:	08 95       	ret

00007ca4 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT  = 0;
    7ca4:	10 92 da 00 	sts	0x00DA, r1
	UHINT   = 0;
	OTGINT  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
    7ca8:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    7cac:	08 95       	ret

00007cae <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    7cae:	1f 92       	push	r1
    7cb0:	0f 92       	push	r0
    7cb2:	0f b6       	in	r0, 0x3f	; 63
    7cb4:	0f 92       	push	r0
    7cb6:	11 24       	eor	r1, r1
    7cb8:	2f 93       	push	r18
    7cba:	3f 93       	push	r19
    7cbc:	4f 93       	push	r20
    7cbe:	5f 93       	push	r21
    7cc0:	6f 93       	push	r22
    7cc2:	7f 93       	push	r23
    7cc4:	8f 93       	push	r24
    7cc6:	9f 93       	push	r25
    7cc8:	af 93       	push	r26
    7cca:	bf 93       	push	r27
    7ccc:	ef 93       	push	r30
    7cce:	ff 93       	push	r31
	#if defined(USB_CAN_BE_DEVICE)
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUS) && USB_INT_IsEnabled(USB_INT_VBUS))
    7cd0:	80 91 da 00 	lds	r24, 0x00DA
    7cd4:	80 ff       	sbrs	r24, 0
    7cd6:	13 c0       	rjmp	.+38     	; 0x7cfe <__vector_10+0x50>
    7cd8:	80 91 d8 00 	lds	r24, 0x00D8
    7cdc:	80 ff       	sbrs	r24, 0
    7cde:	0f c0       	rjmp	.+30     	; 0x7cfe <__vector_10+0x50>
	{
		USB_INT_Clear(USB_INT_VBUS);
    7ce0:	80 91 da 00 	lds	r24, 0x00DA
    7ce4:	8e 7f       	andi	r24, 0xFE	; 254
    7ce6:	80 93 da 00 	sts	0x00DA, r24

		if (USB_VBUS_GetStatus())
    7cea:	80 91 d9 00 	lds	r24, 0x00D9
    7cee:	80 ff       	sbrs	r24, 0
    7cf0:	04 c0       	rjmp	.+8      	; 0x7cfa <__vector_10+0x4c>
		{
			USB_DeviceState = DEVICE_STATE_Powered;
    7cf2:	81 e0       	ldi	r24, 0x01	; 1
    7cf4:	8e bb       	out	0x1e, r24	; 30
			EVENT_USB_Device_Connect();
    7cf6:	cd df       	rcall	.-102    	; 0x7c92 <USB_Event_Stub>
    7cf8:	02 c0       	rjmp	.+4      	; 0x7cfe <__vector_10+0x50>
		}
		else
		{
			USB_DeviceState = DEVICE_STATE_Unattached;		
    7cfa:	1e ba       	out	0x1e, r1	; 30
			EVENT_USB_Device_Disconnect();
    7cfc:	ca df       	rcall	.-108    	; 0x7c92 <USB_Event_Stub>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPEND) && USB_INT_IsEnabled(USB_INT_SUSPEND))
    7cfe:	80 91 e1 00 	lds	r24, 0x00E1
    7d02:	80 ff       	sbrs	r24, 0
    7d04:	1c c0       	rjmp	.+56     	; 0x7d3e <__vector_10+0x90>
    7d06:	80 91 e2 00 	lds	r24, 0x00E2
    7d0a:	80 ff       	sbrs	r24, 0
    7d0c:	18 c0       	rjmp	.+48     	; 0x7d3e <__vector_10+0x90>
	{
		USB_INT_Clear(USB_INT_SUSPEND);
    7d0e:	80 91 e1 00 	lds	r24, 0x00E1
    7d12:	8e 7f       	andi	r24, 0xFE	; 254
    7d14:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_SUSPEND);
    7d18:	80 91 e2 00 	lds	r24, 0x00E2
    7d1c:	8e 7f       	andi	r24, 0xFE	; 254
    7d1e:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUP);
    7d22:	80 91 e2 00 	lds	r24, 0x00E2
    7d26:	80 61       	ori	r24, 0x10	; 16
    7d28:	80 93 e2 00 	sts	0x00E2, r24
		
		USB_CLK_Freeze();
    7d2c:	80 91 d8 00 	lds	r24, 0x00D8
    7d30:	80 62       	ori	r24, 0x20	; 32
    7d32:	80 93 d8 00 	sts	0x00D8, r24
		
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		  USB_PLL_Off();
    7d36:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    7d38:	85 e0       	ldi	r24, 0x05	; 5
    7d3a:	8e bb       	out	0x1e, r24	; 30
		EVENT_USB_Device_Suspend();
    7d3c:	aa df       	rcall	.-172    	; 0x7c92 <USB_Event_Stub>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUP) && USB_INT_IsEnabled(USB_INT_WAKEUP))
    7d3e:	80 91 e1 00 	lds	r24, 0x00E1
    7d42:	84 ff       	sbrs	r24, 4
    7d44:	29 c0       	rjmp	.+82     	; 0x7d98 <__vector_10+0xea>
    7d46:	80 91 e2 00 	lds	r24, 0x00E2
    7d4a:	84 ff       	sbrs	r24, 4
    7d4c:	25 c0       	rjmp	.+74     	; 0x7d98 <__vector_10+0xea>
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
    7d4e:	80 e1       	ldi	r24, 0x10	; 16
    7d50:	89 bd       	out	0x29, r24	; 41
    7d52:	89 b5       	in	r24, 0x29	; 41
    7d54:	82 60       	ori	r24, 0x02	; 2
    7d56:	89 bd       	out	0x29, r24	; 41
			while (!(USB_PLL_IsReady()));
    7d58:	09 b4       	in	r0, 0x29	; 41
    7d5a:	00 fe       	sbrs	r0, 0
    7d5c:	fd cf       	rjmp	.-6      	; 0x7d58 <__vector_10+0xaa>
		}

		USB_CLK_Unfreeze();
    7d5e:	80 91 d8 00 	lds	r24, 0x00D8
    7d62:	8f 7d       	andi	r24, 0xDF	; 223
    7d64:	80 93 d8 00 	sts	0x00D8, r24

		USB_INT_Clear(USB_INT_WAKEUP);
    7d68:	80 91 e1 00 	lds	r24, 0x00E1
    7d6c:	8f 7e       	andi	r24, 0xEF	; 239
    7d6e:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_WAKEUP);
    7d72:	80 91 e2 00 	lds	r24, 0x00E2
    7d76:	8f 7e       	andi	r24, 0xEF	; 239
    7d78:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_SUSPEND);
    7d7c:	80 91 e2 00 	lds	r24, 0x00E2
    7d80:	81 60       	ori	r24, 0x01	; 1
    7d82:	80 93 e2 00 	sts	0x00E2, r24
		
		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
		EVENT_USB_Device_Connect();
		#else
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
    7d86:	80 91 96 01 	lds	r24, 0x0196
    7d8a:	88 23       	and	r24, r24
    7d8c:	11 f4       	brne	.+4      	; 0x7d92 <__vector_10+0xe4>
    7d8e:	83 e0       	ldi	r24, 0x03	; 3
    7d90:	01 c0       	rjmp	.+2      	; 0x7d94 <__vector_10+0xe6>
    7d92:	84 e0       	ldi	r24, 0x04	; 4
    7d94:	8e bb       	out	0x1e, r24	; 30
		EVENT_USB_Device_WakeUp();		
    7d96:	7d df       	rcall	.-262    	; 0x7c92 <USB_Event_Stub>
		#endif
	}
   
	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    7d98:	80 91 e1 00 	lds	r24, 0x00E1
    7d9c:	83 ff       	sbrs	r24, 3
    7d9e:	22 c0       	rjmp	.+68     	; 0x7de4 <__vector_10+0x136>
    7da0:	80 91 e2 00 	lds	r24, 0x00E2
    7da4:	83 ff       	sbrs	r24, 3
    7da6:	1e c0       	rjmp	.+60     	; 0x7de4 <__vector_10+0x136>
	{
		USB_INT_Clear(USB_INT_EORSTI);
    7da8:	80 91 e1 00 	lds	r24, 0x00E1
    7dac:	87 7f       	andi	r24, 0xF7	; 247
    7dae:	80 93 e1 00 	sts	0x00E1, r24

		USB_DeviceState         = DEVICE_STATE_Default;
    7db2:	82 e0       	ldi	r24, 0x02	; 2
    7db4:	8e bb       	out	0x1e, r24	; 30
		USB_ConfigurationNumber = 0;
    7db6:	10 92 96 01 	sts	0x0196, r1

		USB_INT_Clear(USB_INT_SUSPEND);
    7dba:	80 91 e1 00 	lds	r24, 0x00E1
    7dbe:	8e 7f       	andi	r24, 0xFE	; 254
    7dc0:	80 93 e1 00 	sts	0x00E1, r24
		USB_INT_Disable(USB_INT_SUSPEND);
    7dc4:	80 91 e2 00 	lds	r24, 0x00E2
    7dc8:	8e 7f       	andi	r24, 0xFE	; 254
    7dca:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUP);
    7dce:	80 91 e2 00 	lds	r24, 0x00E2
    7dd2:	80 61       	ori	r24, 0x10	; 16
    7dd4:	80 93 e2 00 	sts	0x00E2, r24

		Endpoint_ClearEndpoints();
    7dd8:	57 de       	rcall	.-850    	; 0x7a88 <Endpoint_ClearEndpoints>

		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
    7dda:	80 e0       	ldi	r24, 0x00	; 0
    7ddc:	60 e0       	ldi	r22, 0x00	; 0
    7dde:	42 e0       	ldi	r20, 0x02	; 2
    7de0:	40 de       	rcall	.-896    	; 0x7a62 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    7de2:	57 df       	rcall	.-338    	; 0x7c92 <USB_Event_Stub>
	}
	
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    7de4:	80 91 e1 00 	lds	r24, 0x00E1
    7de8:	82 ff       	sbrs	r24, 2
    7dea:	0a c0       	rjmp	.+20     	; 0x7e00 <__vector_10+0x152>
    7dec:	80 91 e2 00 	lds	r24, 0x00E2
    7df0:	82 ff       	sbrs	r24, 2
    7df2:	06 c0       	rjmp	.+12     	; 0x7e00 <__vector_10+0x152>
	{
		USB_INT_Clear(USB_INT_SOFI);
    7df4:	80 91 e1 00 	lds	r24, 0x00E1
    7df8:	8b 7f       	andi	r24, 0xFB	; 251
    7dfa:	80 93 e1 00 	sts	0x00E1, r24
		
		EVENT_USB_Device_StartOfFrame();
    7dfe:	49 df       	rcall	.-366    	; 0x7c92 <USB_Event_Stub>
		EVENT_USB_UIDChange();

		USB_ResetInterface();
	}
	#endif
}
    7e00:	ff 91       	pop	r31
    7e02:	ef 91       	pop	r30
    7e04:	bf 91       	pop	r27
    7e06:	af 91       	pop	r26
    7e08:	9f 91       	pop	r25
    7e0a:	8f 91       	pop	r24
    7e0c:	7f 91       	pop	r23
    7e0e:	6f 91       	pop	r22
    7e10:	5f 91       	pop	r21
    7e12:	4f 91       	pop	r20
    7e14:	3f 91       	pop	r19
    7e16:	2f 91       	pop	r18
    7e18:	0f 90       	pop	r0
    7e1a:	0f be       	out	0x3f, r0	; 63
    7e1c:	0f 90       	pop	r0
    7e1e:	1f 90       	pop	r1
    7e20:	18 95       	reti

00007e22 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    7e22:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    7e24:	8e b3       	in	r24, 0x1e	; 30
    7e26:	88 23       	and	r24, r24
    7e28:	61 f0       	breq	.+24     	; 0x7e42 <USB_USBTask+0x20>
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();
    7e2a:	10 91 e9 00 	lds	r17, 0x00E9
	
		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
    7e2e:	10 92 e9 00 	sts	0x00E9, r1

		if (Endpoint_IsSETUPReceived())
    7e32:	80 91 e8 00 	lds	r24, 0x00E8
    7e36:	83 ff       	sbrs	r24, 3
    7e38:	01 c0       	rjmp	.+2      	; 0x7e3c <USB_USBTask+0x1a>
		  USB_Device_ProcessControlRequest();
    7e3a:	0d dd       	rcall	.-1510   	; 0x7856 <USB_Device_ProcessControlRequest>
#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();
    7e3c:	17 70       	andi	r17, 0x07	; 7
		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
		  USB_Device_ProcessControlRequest();
		
		Endpoint_SelectEndpoint(PrevEndpoint);
    7e3e:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_DEVICE)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_HOST)
		  USB_HostTask();
	#endif
}
    7e42:	1f 91       	pop	r17
    7e44:	08 95       	ret

00007e46 <_exit>:
    7e46:	f8 94       	cli

00007e48 <__stop_program>:
    7e48:	ff cf       	rjmp	.-2      	; 0x7e48 <__stop_program>
